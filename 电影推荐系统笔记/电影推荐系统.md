# 1 推荐系统概述

## 1.1 什么是推荐系统

> 推荐系统是信息过载所采用的措施，面对海量的数据信息，从中快速推荐出符合用户特点的物品。一些人的“选择恐惧症”、没有明确需求的人.
>
> 信息消费者：如何从大量信息中找到自己感兴趣的信息是一件很困难的事。
>
> 信息生产者：如何让自己生产的信息脱颖而出，收到大众的喜爱，也是一件很困难的事情。
>
> 以前解决这个问题：分类   目录和搜索引擎，比如hao123、百度、谷歌。有弊端，信息量小、不够个性化、必须有明确目标。
>
> 推荐系统是自动化的通过分析用户的历史行为数据，完成用户的个性化建模，从而主动给用户推荐能够满足他们兴趣和需求的信息的软件系统。

![image-20230325160742873](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325160742873.png)

**推荐系统要解决的问题：**

- 解决如何从大量信息中找到自己感兴趣的信息
- 解决如何让自己生产的信息脱颖而出，受到大众的喜爱

**推荐系统的组成：**

- 前端的交互界面
- 日志系统
- 推荐算法系统

**推荐系统的参与方：**

- 用户
- 物品提供者
- 提供推荐系统的网站

![image-20230325161441507](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325161441507.png)

> 好的推荐系统是一个能够让三方共赢的系统

## 1.2 推荐系统的评测方法

- 离线实验【利用原始的数据集进行训练，在后台进行】
- 用户调查【通过发布问卷或做任务的形式让用户完成，然后进行分析】
- 在线实验【实时推荐，通过用户的实时点击进行分析】

### 1.2.1 离线实验

> 离线实验室通过对离线数据集进行训练集和测试集的划分和测试，完成对评测指标的结果收集。

(1) 通过日志系统获得用户行为数据，并按照一定格式生成一个标准的数据集

(2)将数据集按照一定的规则分成训练集和测试集

(3)在训练集上训练用户兴趣模型，在测试集上进行预测 

(4) 通过事先定义的离线指标评测算法在测试集上的预测结果

![image-20230325162257816](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325162257816.png)

### 1.2.2 用户调查

> 用户调查需要有一些真实用户，让他们在需要测试的推荐系统上完成一些任务。在他们完成任务时，我们需要观察和记录他们的行为，并让他们回答一些问题。最后，我们需要通过分析他们的行为和答案了解测试系统的性能。
>
>  它的优点是可以获得很多体现用户主观感受的指标，相对在线实验风险很低，出现错误后很容易弥补。缺点是招募测试用户代价较大，很难组织大规模的测试用户，因此会使测试结果的统计意义不足

### 1.2.3 在线实验

> 将推荐系统上线进行测试，并和旧的算法系统进行==AB==测试，使用户流量随机分配到新旧两个系统中，然后统计用户的反馈数据进而进行系统的指标统计和比对。

![image-20230325162411015](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325162411015.png)

- 用户进入网站后，流量分配系统决定用户是否需要被进行==AB==测试，如果需要的话，流量分配系统会给用户打上在测试中属于什么分组的标签。
- 然后用户浏览网页，而用户在浏览网页时的行为都会被通过日志系统发回后台的日志数据库。
- 此时，如果用户有测试分组的标签，那么该标签也会被发回后台数据库。
- 在后台，实验人员的工作首先是配置流量分配系统，决定满足什么条件的用户参加什么样的测试。
- 其次，实验人员需要统计日志数据库中的数据，通过评测系统生成不同分组用户的实验报告，并比较和评测实验结果。

## 1.3 推荐算法

### 1.3.1 基于内容的推荐算法

> 基于内容的推荐算法，原理是用户喜欢和自己关注过的Item在内容上类似的Item，比如你看了哈利波特I，基于内容的推荐算法发现哈利波特II-VI，与你以前观看的在内容上面（共有很多关键词）有很大关联性，就把后者推荐给你

本项目中采用ElasticSearch来实现多个电影之间的相似度计算。

### 1.3.2 基于模型的推荐算法

> 该类型的推荐算法是通过预先设定的计算模型来实现推荐，常常用于==实时推荐==，相比其他离线推荐算法可以缩短推荐实现

- 本项目中实时推荐算法通过根据具体业务构建了相应的推荐模型来实现推荐。
- 模型算法先写出来，数据进来之后，根据模型计算

### 1.3.3 协同过滤推荐算法

#### 1.3.3.1 协同过滤算法思想

- 协同：用户与用户之间、用户和网站之间等进行不断的互动，慢慢过滤掉自己不感兴趣的物品，从而满足自己的需求。
- 学术界对于实现协同过滤有很多方法
  - 比如基于邻域的方法(neighborhood-based)
    - ==基于用户的协同过滤算法 这种算法给用户推荐和他兴趣相似的其他用户喜欢的物品。==
    - ==基于物品的协同过滤算法 这种算法给用户推荐和他之前喜欢的物品相似的物品。==
  - 隐语义模型 (latent factor model)
  - 基于图的随机游走算法(random walk on graph)

实现协同过滤，步骤：

- 收集用户偏好
- 找到相似的用户或者物品
- 计算推荐

**数据准备：**

- 用户ID

  - 系统的业务数据库获得

- 物品ID

  - 系统的业务数据库获得

- 偏好值

  - ==偏好值==就是用户对物品的喜爱程度，推荐系统所做的事就是根据这些数据为用户推荐他还没有见过的物品，并且猜测这个物品用户喜欢的概率比较大。

  - 偏好值的采集一般会有很多办法，比如评分、投票、转发、保存书签、页面停留时间等等
  - 然后系统根据用户的这些行为流水，采取减噪、归一化、加权等方法综合给出偏好值。
  - 一般不同的业务系统给出偏好值的计算方法不一样。

#### 1.3.3.2 相似性度量

> 基于用户的推荐和基于物品的推荐都需要找相似，即需要找相似用户以及相似物品。比如一个男生和一个女生是朋友，不能讲该女生穿的衣服推荐给男生。要找相似。那么衡量的指标有哪些？比如皮尔逊相关系数、欧式距离、同现相似度、Cosine相似度、Tanimoto系数等

##### 1.3.3.2.1 皮尔逊相关系数

> 皮尔逊相关系数是介于1到-1之间的数，他衡量两个一一对应的序列之间的线性相关性。也就是两个序列一起增大或者一起减小的可能性。两个序列正相关值就趋近1，否者趋近于0。

![image-20230325165419778](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325165419778.png)

数学含义：两个序列协方差与二者方差乘积的比值

如果比较两个人的相似度，那么他们所有共同评价过的物品可以看做两个人的特征序列，这两个特征序列的**相似度**就可以用皮尔逊相关系数去衡量。物品的相似度比较也是如此。

==皮尔逊对于稀疏矩阵表现不好，可以通过引入权重进行优化。==

##### 1.3.3.2.2 欧氏距离

> 可以将两个人所有共同评价过的物品看做这个人的特征，将这些特征看做是空间中的点，计算两点之间的距离。

![image-20230325165712748](../../image-20230325165712748.png)

##### 1.3.3.2.3 同现相似度

 物品i和物品j的同相似度公式定义:

![image-20230325165845846](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325165845846.png)

其中，分母是喜欢物品i的用户数，而分子则是同时喜欢物品i和物品j的用户数。因此，上述公式可用理解为喜欢物品i的用户有多少比例的用户也喜欢j  (和关联规则类似)

  但上述的公式存在一个问题，如果物品j是热门物品，有很多人都喜欢，则会导致Wij很大，接近于1。因此会造成任何物品都和热门物品交有很大的相似度。为此我们用如下公式进行修正：

![image-20230325165857335](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325165857335.png)

这个格式惩罚了物品j的权重，因此减轻了热门物品和很多物品相似的可能性。(也归一化了[i,j]和[j,i])

#### 1.3.3.3  邻域大小

有了相似度的比较，那么比较多少个用户或者物品为好呢？一般会有基于固定大小的邻域以及基于阈值的领域。具体的数值一般是通过对模型的评比分数进行调整优化。

![image-20230325165933480](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325165933480.png)

![image-20230325165936836](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325165936836.png)

#### 1.3.3.4  基于用户的CF

模型核心算法伪代码表示:

![image-20230325170033094](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170033094.png)

基于该核心算法，完成用户商品矩阵：

![image-20230325170042308](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170042308.png)

预测用户对于未评分的物品的分值，然后按照降序排序，进行推荐

#### 1.3.3.5 基于物品的CF

先计算出物品-物品的相似矩阵：

![image-20230325170120128](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170120128.png)

基于上面的结果：

![image-20230325170123828](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170123828.png)

给用户推送预测偏好值n个最高的物品。

#### 1.3.3.6 ALS矩阵分解模型

##### 1.3.3.6.1 矩阵分解模型

 在协同过滤推荐算法中，最主要的是产生用户对物品的打分，用户对物品的打分行为可以表示成一个评分矩阵A(m*n)，表示m个用户对n各物品的打分情况。如下图所示：

![image-20230325170441181](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170441181.png)           

其中，A(i,j)表示用户user i对物品item j的打分。但是，用户不会对所有物品打分，图中？表示用户没有打分的情况，所以这个矩阵A很多元素都是空的，我们称其为“缺失值（missing value）”，是一个稀疏矩阵。在推荐系统中，我们希望得到用户对所有物品的打分情况，如果用户没有对一个物品打分，那么就需要预测用户是否会对该物品打分，以及会打多少分。这就是所谓的“矩阵补全（填空）”。

我们从另外一个层面考虑用户对物品的喜爱程序，而不是通过用户的推荐。用户之所以喜欢一个物品，绝大对数是因为这个物品的某些属性和这个用户的属性是一致或者是接近的，比如一个人总是具有爱国情怀或者侠义情怀，那么根据这些推断一定喜欢比如《射雕英雄传》、抗战剧等电视剧，因为这些电视剧所表达的正是侠义和爱国。可以设想用户拥有某些隐含的特征、物品也具有某种隐含的特征，如果这些特征都相似，那么很大程度上用户会喜欢这个物品。

根据上面的假设，我们可以把评分矩阵表示成两个低纬度的矩阵相乘，如下:

![image-20230325170456804](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170456804.png)

我们希望学习到一个P代表user的特征，Q代表item的特征。特征的每一个维度代表一个隐性因子，比如对电影来说，这些隐性因子可能是导演，演员等。当然，这些隐性因子是**机器学习**到的，具体是什么含义我们不确定。

  ALS 的核心就是下面这个假设：打分矩阵A是近似低秩的。换句话说，一个m*n的打分矩阵A 可以用两个小矩阵U(M\*k)和V(N\*k)的乘积来近似:![image-20230325170643120](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170643120.png)。这样我们就把整个系统的自由度从![image-20230325170656842](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170656842.png)一下降到了![image-20230325170706399](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170706399.png) 。一个人的喜好映射到了一个低维向量![image-20230325170725340](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170725340.png)，一个电影的特征变成了纬度相同的向量![image-20230325170734461](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170734461.png)，那么这个人和这个电影的相似度就可以表述成这两个向量之间的内积![image-20230325170741391](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170741391.png)。

我们把打分理解成相似度，那么**打分矩阵A(m\*n)**就可以由***用户喜好特征矩阵U(m\*k)”***和**产品特征矩阵V(n\*k)”**的乘积![image-20230325170835527](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170835527.png)来近似了。这种方法被称为概率矩阵分解算法(probabilistic matrix factorization，PMF)。ALS算法是PMF在数值计算方面的应用。

##### 1.3.3.6.1.2  交替最小二乘法（ALS）

为了使低秩矩阵X和Y尽可能地逼近R，需要最小化下面的平方误差损失函数：

![image-20230325170922222](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170922222.png)

 考虑到矩阵的稳定性问题，使用吉洪诺夫正则化Tikhonov regularization，则上式变为：

 ![image-20230325170927617](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170927617.png)

所以整个矩阵分解模型的损失函数为：

 ![image-20230325170932491](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170932491.png)

有了损失函数之后，下面就开始谈优化方法了，通常的优化方法分为两种：交叉最小二乘法（alternative least squares）和随机梯度下降法（stochastic gradient descent）。本次使用交叉最小二乘法（ALS）来最优化损失函数。[算法](http://lib.csdn.net/base/datastructure)的思想就是：我们先随机生成![image-20230325170949903](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170949903.png)然后固定它求解![image-20230325170958400](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325170958400.png)，再固定![image-20230325171004485](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171004485.png)求解![image-20230325171010522](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171010522.png)，这样交替进行下去，直到取得最优解min(C)。因为每步迭代都会降低误差，并且误差是有下界的，所以ALS 一定会收敛。但由于问题是非凸的，ALS 并不保证会收敛到全局最优解。但在实际应用中，ALS 对初始点不是很敏感，是不是全局最优解造成的影响并不大。

算法的执行步骤：

1、先随机生成一个![image-20230325171021348](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171021348.png)。一般可以取0值或者全局均值。

2、固定![image-20230325171028744](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171028744.png)（即：认为![image-20230325171034258](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171034258.png)是已知的常量），来求解![image-20230325171040914](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171040914.png)。

此时，损失函数为： 

![image-20230325171048617](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171048617.png)

由于C中只有Vj一个未知变量，因此C的最优化问题转化为最小二乘问题，用最小二乘法求解Vj的最优解：

固定j（j=1,2,......,n），则：C的导数

 ![image-20230325171059180](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171059180.png)

令![image-20230325171114360](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171114360.png)，得到：

 ![image-20230325171118887](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171118887.png)

即：

![image-20230325171127294](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171127294.png)

令![image-20230325171133424](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171133424.png)，![image-20230325171142761](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171142761.png)，则：

 ![image-20230325171146809](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171146809.png)

按照上式依次计算v1，v2，......，vn，从而得到![image-20230325171207814](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171207814.png)。

3、固定![image-20230325171222412](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171222412.png)（即：认为![image-20230325171227796](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171227796.png)是已知的量），来求解![image-20230325171233430](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171233430.png)。

此时，损失函数为： 

![image-20230325171214437](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171214437.png)

同理，用步骤2中类似的方法，可以计算ui的值：

 ![image-20230325171239848](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171239848.png)

令![image-20230325171243776](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171243776.png)，得到：

![image-20230325171248381](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171248381.png)

即：
 ![image-20230325171255158](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171255158.png)

令![image-20230325171304075](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171304075.png)，![image-20230325171314104](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171314104.png)，则：

 ![image-20230325171318636](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171318636.png)

依照上式依次计算u1，u2，......，um，从而得到![image-20230325171325929](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171325929.png)。

4、循环执行步骤2、3，直到损失函数C的值收敛（或者设置一个迭代次数N，迭代执行步骤2、3 N次后停止）。这样，就得到了C最优解对应的矩阵U、V。

### 1.3.4 组合推荐

推荐算法有很多种，本项目只涉及到了基于内容的推荐、基于模型的实时推荐以及协同过滤推荐。这种组合式的应用推荐就叫组合推荐（Hybrid Recommendation）。研究和应用最多的是内容推荐和协同过滤推荐的组合。最简单的做法就是分别用基于内容的方法和协同过滤推荐方法去产生一个推荐预测结果，然后用某方法组合其结果。

# 2 电影推荐系统的概述

![image-20230325171443593](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230325171443593.png)

## 2.1 项目体系架构

![电影推荐系统架构图](../../image-20230323200209281.png)

**用户可视化：**主要负责实现和用户的交互以及业务数据的展示，主体采用==HTMl==和==CSS==和==JavaScript==前端三件套以及==SpringBoot==和==Thymeleaf==进行实现。

**综合业务服务：**主要实现JavaEE层面整体的业务逻辑，通过==SpringBoot==进行构建，对接业务需求。

**【数据存储部分】**

**业务数据库：**项目采用广泛应用的文档数据库==MongDB==作为主数据库，主要负责平台业务逻辑数据的存储。

**搜索服务器：**项目爱用ElasticSearch作为模糊检索服务器，通过利用ES强大的匹配查询能力实现基于内容的推荐服务。

**缓存数据库：**项目采用Redis作为缓存数据库，主要用来支撑实时推荐系统部分对于数据的高速获取需求。

**【离线推荐部分】**

**离线统计服务：**批处理统计性业务采用==Spark Core== +== Spark SQL==进行实现，实现对指标类数据的统计任务。

**离线推荐服务：**离线推荐业务采用==Spark Core== + ==Spark MLlib==进行实现，采用==ALS==算法进行实现。

**【实时推荐部分】**

**日志采集服务：**通过利用==Flume-ng==对业务平台中用户对于电影的一次评分行为进行采集，实时发送到==Kafka==集群。

**消息缓冲服务：**项目采用==Kafka==作为流式数据的缓存组件，接受来自==Flume==的数据采集请求。并将数据推送到项目的实时推荐系统部分。

**实时推荐服务：**项目采用==Spark Streaming==作为实时推荐系统，通过接收==Kafka==中缓存的数据，通过设计的推荐算法实现对实时推荐的数据处理，并将结构合并更新到==MongoDB==数据库。

## 2.2 项目数据流程

![image-20230403211658487](%E7%94%B5%E5%BD%B1%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.assets/image-20230403211658487.png)

【系统初始化部分】

1. 通过Spark SQL将系统初始化数据加载到MongoDB和ElasticSearch中。

【离线推荐部分】

1. 通过Azkaban实现对于离线统计服务以离线推荐服务的调度，通过设定的运行时间完成对任务的触发执行。
2. 离线统计服务从MongoDB中加载数据，将【电影平均评分统计】、【电影评分个数统计】、【最近电影评分个数统计】三个统计算法进行运行实现，并将计算结果回写到MongoDB中；离线推荐服务从MongoDB中加载数据，通过ALS算法分别将【用户推荐结果矩阵】、【影片相似度矩阵】回写到MongoDB中。

【实时推荐部分】

1. Flume从综合业务服务的运行日志中读取日志更新，并将更新的日志实时推送到Kafka中；Kafka在收到这些日志之后，通过kafkaStream程序对获取的日志信息进行过滤处理，获取用户评分数据流【UID|MID|SCORE|TIMESTAMP】，并发送到另外一个Kafka队列；Spark Streaming监听Kafka队列，实时获取Kafka过滤出来的用户评分数据流，融合存储在Redis中的用户最近评分队列数据，提交给实时推荐算法，完成对用户新的推荐结果计算；计算完成之后，将新的推荐结构和MongDB数据库中的推荐结果进行合并。

【业务系统部分】

1. 推荐结果展示部分，从MongoDB、ElasticSearch中将离线推荐结果、实时推荐结果、内容推荐结果进行混合，综合给出相对应的数据。
2. 电影信息查询服务通过对接MongoDB实现对电影信息的查询操作。
3. 电影评分部分，获取用户通过UI给出的评分动作，后台服务进行数据库记录后，一方面将数据推动到Redis群中，另一方面，通过预设的日志框架输出到Tomcat中的日志中。
4. 项目通过ElasticSearch实现对电影的模糊检索。
5. 电影标签部分，项目提供用户对电影打标签服务。

## 4.3 数据表模型





## 4.4 项目基础环境













































































解决冷启动问题：

- 用户刚刚注册时没有实时推荐的内容
- 用户在注册后设置感兴趣类别，根据用户选择类别进行实时推荐计算

、