# 第三章、栈和队列

> 栈的队列的应用

**栈和队列是限定插入和删除只能在表的"端点"进行的线性表**。

**栈的应用**：数制转换、表达式求值、括号匹配问题、八皇后问题、行编辑程序、函数调用、迷宫求解、递归调用的实现。

**队列的应用**：

- 脱机打印输出：按申请的先后顺序依次输出。
- 多用户系统中，多个用户排成队，分时地循环使用CPU和主存。
- 按用户的优先级排成多个队，每个优先级一个队列。
- 实时控制系统中，信号按接收的先后顺序依次处理。
- 网络电文传输，按到达的时间先后顺序依次进行。

> 栈的特点

**栈**：仅在表尾进行插入、删除操作的线性表。

表尾称为**栈顶**。表头称为**栈底**。

![出栈顺序](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/2020110221344766.png)

![出栈顺序](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201102213503142.png)



## 1. 案例引入

> 案例1：进制转换。十进制整数N向其它进制数d(2、8、16)的转换是计算机实现计算的基本问题。

**转换法则：除以d倒取余**。

```java
public class DecimalToBinary {
	public static void main(String[] args) {
		Stack<Integer> s = new Stack<>();
		int x = 18;
		while (x > 0) {
			int remain = x % 2;
			s.push(remain);
			x = x >> 1;
		}
		while(!s.empty()) System.out.print(s.pop());
	}
}
```



> 案例2：括号匹配的检验

**假设表达式中允许包含两种括号：圆括号和方括号**。

**其嵌套的顺序随意，即**：

- `( [] () ) or [ ( [] [] ) ]`为正确格式；
- `[ ( ] ) or ( [ () ) or ( () ] )`为错误格式。

![括号匹配检验](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/2020110319240837.png)



> 案例3：表达式求值

![表达式求值](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/2020110319300938.png)



> 案例4：舞伴问题。

假设在舞会上，男士和女士各自排成一队。舞会开始时，依次从男队和女队的队头各出一人配成舞伴。如果两队初始人数不相同，则较长的那一队中未配对者等待下一轮舞曲。现要求写一算法模拟上述舞伴配对问题。

**分析：显然符合先进先出的特性，可以使用队列作为算法的数据结构**。

**算法**：

- 首先构造两个队列。
- 依次将队头元素出队配成舞伴。
- 某队为空，则另外一队等待着的则是下一舞曲第一个可获得舞伴的人。



## 2. 栈的存储结构

![栈的顺序存储](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201103194433152.png)

**栈空的标志**：`top == base`。

**栈满的标志**：`top == stacksize `。

```c
#define MAXSIZE 100
typedef struct {
    int data[MAXSIZE];
    int top;
} SqStack;
```



## 3. 队列的存储结构



# 第四章、串、数组和广义表

> 回顾

- 栈和队列是**操作受限**的线性表。

- 串、数组和广义表是**内容受限**的线性表。
  - 串中的每一个数据元素只能是字符类型。
  - 每一个数据元素是线性表我们称为数组。
  - 广义表中的数据元素又是一个广义表。

## 1. 串

### 1.1. 串的术语

![串](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201101153212442.png)

**串(String)**：零个或多个任意**字符组成的有限序列**。

**子串**：串中任意个连续字符组成的**子序列**称为该串的子串。

**主串**：包含字串的串相应的称为主串。

![子串](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201101153458593.png)

**字符位置**：字符**在序列中的序号**为该字符在串中的位置，

**子串位置**：**子串第一个字符**在主串中的位置。

**空格串**：由一个或多个空格组成的串，**与空串不同**。

![例题](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/202011011540480.png)

**串相等**：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的。

**注：所有的空串都是相等的**！



### 1.2. 串的存储结构

**(1)顺序存储结构(实际用的多)**

```c
#define MAXSIZE 255
typedef struct {
    char ch[MAXSIZE+1];       // 存储串的一维数组
    int length;               // 串的当前长度
} SqString;
```

**(2)链式存储结构——块链结构**

![串的链式存储结构](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201101155130615.png)

```c
#define CHUNKSIZE 80

typedef struct _chunk {
    char ch[CHUNKSIZE];
    struct _chunk* next;
} Chunk;

typedef struct {
    Chunk* head;              // 头指针
    Chunk* tail;              // 尾指针
    int curlen;               // 串的当前长度
} LString;
```



### 1.3. 串的模式匹配算法

**算法目的(定位)**：确定主串中所含子串(模式串)第一次出现的位置。

 

> Brute Force——BF算法：穷举法

![BF算法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201101162950113.png)

BF算法：

- 将主串的第`pos`个字符和模式串的第一个字符比较；
- 若相等，继续逐个比较后续字符；
- 若不等，从主串的下一字符起，重新与模式串的第一个字符比较。
- 直到主串的一个连续子串字符序列与模式串相等。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功；
- 否则匹配失败，返回-1.

```c
/**
* @Param：S 主串
* @Param：T 模式串
*/
int index_BF(SqString S, SqString T) {
    int i = 0;
    int j = 0;
    while(i < S.length && j < T.length) {
        if(S.ch[i] == T.ch[i]) {
            i++;
            j++;
        } else {
            j = 0;                              // 模式串指针到起始位置
            i = i - j + 1;                      // 主串指针回溯
        }
    }
    if(j >= T.length) return i - T.length;      // 模式串匹配成功
    else return -1;                             // 模式串匹配失败
}
```

**BF算法时间复杂度**：`O(n*m)`。



> KMP算法

KMP算法思想：利用已经**部分匹配的结果**而加快模式串的滑动速度。且**主串的指针不必回溯**！可以将时间复杂度提高到`O(n+m)`。

**(1)模式串最长公共前后缀构造next数组**。

![next数组](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201101172917189.png)



**(2)next数组构造**。

![next数组](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/202011011742405.png)

```c
void getNext(SqString T, int &next[]) {
    int i = 1;
    int j = 0;
    next[0] = 0;
    next[1] = 0;
    while(i < T.length) {
        if(j == 0 || T.ch[i] == T.ch[j]) {
            i++;
            j++;
            next[i] = j; 
        }else {
            j = next[j];
        }
    }
}
```

next数组构造有两种方法：

- 最长公共前后缀(人方便)。
- 根据next数组下标(计算机使用)。



**(3)KMP算法**。

```c
int index_KMP(SqString S, SqString T) {
    int i = 0;
    int j = 0;
    while(i < S.lengt && j < T.length) {
        if(j == 0 || S.ch[i] == T.ch[j]) {
            i++;
            j++;
        } else {
            j = next[j];                  // i不变，j后退
        }
    }
    if(j >= T.length) return i-T.length;
    else return -1;
}
```



**(4)nextval数组**。

![nextval](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201101191623554.png)



## 2. 数组

**数组**：按照一定格式排列起来，具有相同类型的数据元素的集合。

**注意**：数组是多维的，但是**存储数据元素的内存单元是一维的**，因此，在存储数组结构之前，需要解决将多维关系映射到一维关系的问题。

> 二维数组

**二维数组行序优先表示**。

![二维数组行序优先表示](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201101193311731.png)



> 三维数组

![三维数组](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201103205829997.png)





## 3. 矩阵压缩存储

> 特殊矩阵的压缩存储

**矩阵**：一个由*m×n*个元素排成的*m*行*n*列的表。

**矩阵的常规存储**：将矩阵描述为一个二维数组。

**矩阵常规存储的特点**：

- 可以对其元素进行随机存取；
- 矩阵运算非常简单，存储密度为1。

**不适宜常规存储的矩阵**：

- 值相同的元素很多且呈某种规律；
- 零元素多。

**什么是矩阵的压缩存储**？：

答：为多个相同的非零元素只分配一个存储空间；对零元素不分配空间。

**什么样的矩阵能够压缩**？

答：对称矩阵，对角矩阵、三角矩阵、稀疏矩阵等。



> 对称矩阵

**(1)对称矩阵的特点**

![对称矩阵](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201101215527470.png)

可以**以行序为主序**将元素存放在一个一维数组`sa[n(n+1)/2]`中。



**(2)对称矩阵的压缩存储**

![对称矩阵的压缩存储](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201101221337450.png)



> 三角矩阵

**(1)三角矩阵的压缩存储**

![三角矩阵](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201102200525954.png)



> 对角矩阵

**(1)对角矩阵的压缩存储**。

![对角矩阵](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201102201300254.png)



> 稀疏矩阵

**(1)三元组法(有序的双下标法)**。

![稀疏矩阵](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201102202349744.png)

数组的 *0* 号位置表示**总行数、总列数、非零元素总个数**。

**优点**：非零元素在表中按行序有序存储，因此**便于进行顺序处理的矩阵运算**。

**缺点**：不能随机存取。若按行号存取某一行中的非零元素，则需从头开始进行查找。



**(2)十字链表**。

![十字链表](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201102203355885.png)

![十字链表](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201102203820860.png)

# 第五章、树和二叉树

> 回顾——数据的逻辑结构

**线性结构**：

- 线性表。
- 栈、队列（栈和队列都是操作受限的线性结构）。
- 字符串、数组、广义表。

**非线性结构**：

- 树型结构。
- 图型结构。

## 1. 树和二叉树的定义

### 1.1. 树的基本术语

![树的基本术语](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201025234924433.png)

**树的深度(高度)**：树中结点的最大层次。图中树的深度是4。

**有序树**：树中结点的各子树从左至右有次数（最左边的为第一个还孩子）。

**无序树**：树中结点的各子树无次序。

**森林**：`m(m≥0)`棵互不相交的树的集合。**树一定是森林，森林不定是树**。

> 树结构和线性结构的比较

|     线性结构     |        特点        |        树结构        |        特点        |
| :--------------: | :----------------: | :------------------: | :----------------: |
|  第一个数据元素  |       无前驱       |   根节点(只有一个)   |       无双亲       |
| 最后一个数据元素 |       无后继       | 叶子结点(可以有多个) |       无孩子       |
|   其他数据元素   | 一个前驱，一个后继 |  其他结点(中间结点)  | 一个双亲，多个孩子 |
|       总结       |       一对一       |         总结         |       一对多       |



### 1.2. 二叉树的定义

**(1)二叉树的特点**：

- 每个结点最多有俩孩子(**二叉树中不存在度大于2的结点**)。
- **子树有左右之分，其次序不能颠倒**。
- 二叉树**可以是空集合**，根可以有空的左子树或空的右子树。

**(2)二叉树不是树的特殊情况，二叉树和树是两个不同的概念**：

- 二叉树结点的子树要区分**左子树和右子树**。即使只有一棵子树也要进行区分，说明它是左子树，还是右子树。
- 树当结点只有一个孩子时，就无需区分它是左还是右的次序。因此，二叉树和树是不同的。这是二叉树和树最主要的区别。

![二叉树和树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201026093925956.png)

![思考题](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201026094242207.png)



**(3)二叉树的5种基本形态**

![二叉树的5种基本形态](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201026094607105.png)



## 2. 二叉树的性质

### 2.1. 案例引入

**(1)数据压缩问题：可采用哈夫曼树**。

**(2)利用二叉树求接表达式的值**。

![利用二叉树求表达式的值](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201026095816603.png)



### 2.2. 二叉树的相关公式

(1)二叉树第 i 层结点数量**最多**有：`2^(i-1)`。

(2)深度为 k 的二叉树**最多**有 `2^k - 1`个结点。

(3)对于任何一棵二叉树T，如果叶子树为`n0`，度为2的结点数为`n2`，则`n0 = n2 + 1`。

![n0 = n2 + n1](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201026101415604.png)



**(4)满二叉树**

![满二叉树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201026102234724.png)

Ⅰ满二叉树在同样深度的二叉树种**结点个数最多**。

Ⅱ满二叉树在同样深度的二叉树种**叶子结点个数最多**。



**(5)完全二叉树**

![完全二叉树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201026102610452.png)

注：在满二叉树种，从最后一个结点开始，**连续去掉任意个结点**，即是一棵完全二叉树。

满二叉树特点：

- 叶子只可能分布在层次最大的两层上。
- 对任一结点，如果其右子树的最大层次为 i ，则其左子树的最大层次必为 i 或 i + 1。
- **满二叉树一定是完全二叉树**。

### 2.3. 完全二叉树的性质

(1)具有 n 个结点的完全二叉树的深度为 `[log2n] + 1`（向下取整）。

(2)完全二叉树**双亲结点编号和孩子结点编号**之间的关系。

![完全双亲结点编号和孩子结点编号间的关系](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201026105016814.png)



## 3. 二叉树的存储结构

### 3.1. 顺序存储结构

![二叉树的顺序存储](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201026105816389.png)

```c
/**
* 二叉树顺序存储表示
* SqBiTree = Sequence Binary Tree
*/
#define MAXSIZE 100
typedef char TElemType;

typedef TElemType SqBiTree[MAXSIZE];    // TElemType 代表二叉树的结点类型
SqBiTree bt;
```

**顺序存储结构特点**：

- 结点间关系蕴含在其存储位置之中。
- 浪费空间，适合存**满二叉树或完全二叉树**。



> 例题：二叉树的结点采用顺序存储结构，画出二叉树的表示。

![通过顺序存储结果画出二叉树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201026111541882.png)



### 3.2. 链式存储结构

```c
/**
* 二叉链表存储结构
*/
typedef char TElemType;

typedef struct _btnode {
    TElemType data;
    struct _btnode *lchild;
    struct _btnode *rchild;
} BTNode;
```



> 练习：计算二叉链表种空指针域的数量（空指针域在线索二叉树种可以用到）

![计算二叉树空指针域的数量](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201026113638962.png)



## 4. 遍历二叉树

> 根据遍历序列确定二叉树

**由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以确定唯一一棵二叉树**。

![根据遍历序列确定二叉树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201026131158867.png)



> 遍历算法

### 4.1. 先中后序遍历

**(1)先序遍历**

![先序遍历](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201026140316474.png)

```c
/**
* 递归先序遍历
*/
void preOrderTraverse(BTNode* T) {
    if(!T) return;                   // 递归的出口
    visit(T);                        // 访问
    preOrderTraverse(T->lchild);     // 递归遍历左子树
    preOrderTraverse(T->rchild);     // 递归遍历右子树
}

/**
* 非递归先序遍历
*/
void preOrderTraverse(BTNode* T) {
    if(T == null) return;
    
    Stack s = initStack();
    
    while(!isEmpty(s) || T != null) {
        if(T != null) {
            printf("%c\t", T->data);
            push(s, T);
            T = T->lchild;
        } else {
            BTNode *p = pop(s);
            T = p->rchild;
        }
    }
}
```

**(2)中序遍历**

```c
/**
* 递归中序遍历
*/
void inOrderTraverse(BTNode* T) {
    if(!T) return;                   // 递归的出口
    preOrderTraverse(T->lchild);     // 递归遍历左子树
    visit(T);                        // 访问
    preOrderTraverse(T->rchild);     // 递归遍历右子树
}

/**
* 非递归中序遍历
*/
void inOrderTraverse(BTNode* T) {
    if(T == null) return;
    
    Stack s = initStack();
    
    while(!isEmpty(s) || T != null) {
        if(T != null) {
            push(s, T);
            T = T->lchild;
        } else {
            BTNode *p = pop(s);
            printf("%c\t", p->data);
            T = p->rchild;
        }
    }
}
```

**(3)后序遍历**

```c
void postOrderTraverse(BTNode* T) {
    if(!T) return;                   // 递归的出口
    preOrderTraverse(T->lchild);     // 递归遍历左子树
    preOrderTraverse(T->rchild);     // 递归遍历右子树
    visit(T);                        // 访问
}
```



> 遍历算法的分析

![遍历算法的分析](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201026141005982.png)



### 4.2. 层序遍历

算法：

- 使用队列，将根结点入队；
- 队列不空时循环：从队列中出列一个结点*p，访问它：
  - 若它有左孩子结点，将左孩子结点进队；
  - 若它有右孩子结点，将右孩子结点进队。

```c
void levelOrderTraverse(BTNode* T) {
    if(T == NULL) return;
    enQueue(Q, T);
    while(!isEmpty(Q)) {
        BTNode* p = deQueue(Q);
        printf("%c\t", p->data);
        if(p->lchild) enQueue(Q, p->lchild);
        if(p->rchild) enQueue(Q, p->rchild);
    }
}
```



### 4.3. 遍历算法的应用

> 应用1——复制二叉树

 算法：

- 如果根结点为空，递归结束；
- 否则，申请新结点空间，复制根结点；
  - 递归复制左子树；
  - 递归复制右子树。

```c
void copy(BTNode *T1, BTNode *T2) {
    if(T1 == null) return;
    
    T2 = (BTNode*)malloc(sizeof(BTNode));
    
    T2->data = T1->data;
    copy(T1->lchild, T2->lchild);
    copy(T1->rchild, T2->rchild);
}
```



> 应用2——计算二叉树的深度

算法：

- 如果是空树，则深度为0；
- 否则，递归计算左子树的深度为m，递归计算右子树的深度为n，二叉树的深度为`max{m, n} + 1`。

```c
int depth(BTNode* x) {
    if(x == NULL) return 0;
    int m = depth(x->lchild);
    int n = depth(x->rchild);
    return (m > n ? m : n) + 1;
}
```



> 应用3——计算二叉树结点总数

算法：

- 如果是空树，则结点个数为0；
- 否则，结点个数 = 左子树的结点个数 + 右子树的结点个数 + 1。

```c
int size(BTNode* x) {
    if(x == NULL) return 0;
    return size(x->lchild) + size(x->right) + 1;
}
```



> 应用4——计算二叉树叶子结点的数

算法：

- 如果是空树，则叶子结点个数为0；
- 否则，叶子结点个数 = 左子树叶子结点个数 + 右子树叶子结点个数。

```c
int leaves(BTNode* x) {
    if(x == NULL) return 0;                               // 空树就返回0
    if(x->lchild == NULL && x->rchild == NULL) return 1;  // 如果是叶子结点返回1
    return leaves(x->lchid) + leaves(x->rchild);
}
```



## 5. 线索二叉树

> 为什么要研究线索二叉树？？

![研究线索二叉树的原因](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201027120256702.png)

二叉链表中有`n + 1`个空指针域(n为结点数)，则可以利用这些空指针域：

- 如果某个结点的左孩子为空，则将空的左孩子指针域改为**指向其前驱**；
- 如果某结点的右孩子为空，则将空的右孩子指针域改为**指向其后继**。

**这种改变指向的指针称为"线索"，加上了线索的二叉树称为线索二叉树**。

对二叉树按某种遍历次序使其变为线索二叉树的过程称为**线索化**。



> 线索二叉树的构建

**(1)画线索二叉树**

![线索二叉树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201027121709695.png)



**(2)线索二叉树的标志域**

为了区分`lchild、rchild`指针到底是指向孩子的指针，还是指向前驱或后继的指针，对二叉链表中每个结点增设两个标志域`ltag、rtag`。

<img src="https://img-blog.csdnimg.cn/20201027122129491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JyaW5nb18=,size_16,color_FFFFFF,t_70#pic_center" alt="线索二叉树标志域" style="zoom:150%;" />



**(3)线索二叉树的存储结构**

```c
/**
* Threaded Binary Tree
*/
typedef struct _thrbitnode {
    int data;                            // 数据域
    int ltag, rtag;                      // 标志域
    struct _thrbitnode *lchild;          // 左孩子
    struct _thrbitnode *rchild;          // 右孩子
} ThrBiNode;
```



**(4)先序线索二叉树**

![先序线索二叉树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201027123010878.png)



**(4)中序线索二叉树**

![中序线索二叉树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/2020102712461358.png)



## 6. 树的存储结构

### 6.1. 双亲表示法

**(1)实现：定义结构数组，存放树的结点**。

每个结点含有两个域：

- 数据域：存放结点本身信息。
- 双亲域：指示本结点的双亲结点在数组中的位置。

![双亲表示法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201027130049262.png)



**(2)C语言类型描述**

```c
#define MAXSIZE 100
typedef char TElemType;

/**
* 定义结点
*/
typedef struct {
    TElemType data;            // 结点
    int parent;                // 双亲下标
} PTNode;

/**
* 定义树
*/
typedef struct {
    PTNode nodes[MAXSIZE];
    int r;                    // 根结点的位置
    int n;                    // 结点总数
} PTree;
```



### 6.2. 孩子链表表示法

**(1)孩子链表**

![孩子表示法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201028085742959.png)



**(2)带双亲的孩子链表**

![带双亲的孩子链表](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201028090137973.png)



**(3)C语言定义**

```c
#define MAXSIZE 100
typedef char TElemType;

/**
* 孩子结点定义
*/
typedef struct _childnode {
    int child;
    struct _childnode* next;
} ChildNode;

/**
* 双亲结点的定义
*/
typedef struct {
    TElemType data;
    CNode* firstchild;
} ParentNode;

/**
* 树的定义
*/
typedef struct {
    ParentNode nodes[MAXSIZE];
    int n;                       // 结点数量
    int r;                       // 根节点的位置
} ChildParentBinTree;
```



### 6.3. 孩子兄弟表示法

**(1)实现：用二叉链表作为树的存储结构**。

**链表中每个结点左指针域指向其第一个孩子结点，右指针域指向其下一个兄弟结点**。

![孩子兄弟表示法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201028091403745.png)



**(2)C语言定义**。

```c
/**
* 结点的存储结构
*/
typedef struct _cbnode {
    ElemType data;
    struct _cbnode* firstchild;           // 指向的第一个孩子结点
    struct _cbnode* nextbrother;          // 指向的下一个兄弟结点
} ChildBrotherNode;
```



## 7. 树和森林

> 树转二叉树

![树和森林](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201027125438442.png)



### 7.1. 树与二叉树的转换

> 树转二叉树

![树转化成二叉树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201028092225422.png)

**树转化成二叉树的步骤**：

- **加线(兄弟齐心)**：在兄弟之间加一条线。
- **抹线(割袍断义 保大)**：对于每个结点，除了其左孩子外，去除该结点与其余孩子之间的关系。

**口诀：兄弟相连留长子**。

![树转二叉树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201028093333115.png)



> 二叉树转树

![二叉树转树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201028094038673.png)

**口诀**：

- **左孩右右连双亲**，
- **去掉原来右孩线**。



### 7.2. 森林与二叉树的转换

> 森林转二叉树（二叉树与多棵树之间的关系）

![森林转二叉树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201028095330761.png)

步骤：

- 将各棵树分别转换成二叉树；
- 将每棵树的根节点用线相连；
- **以第一棵树根节点为二叉树的根，再以根节点为轴心，顺时针旋转，构成二叉树型结构**。

**口诀：树变二叉根相连**。



> 二叉树转森林

![二叉树转森林](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201028095855821.png)

**口诀：去掉全部右孩线，孤立二叉再还原**。



### 7.3. 树和森林的遍历

> 树的遍历（三种方式）

- **先根遍历**：若树不空，则先访问根结点，然后依次先根遍历各棵子树。
- **后根遍历**：若树不空，则先依次后根遍历各棵子树，然后访问根结点。
- **层次遍历**：若树不空，则自上而下，从左到右访问树中每个结点。

![树的遍历](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/2020102811070864.png)



> 森林的遍历

**(1)将森林看成由三个部分组成**

- Ⅰ 森林中第一棵树的根节点；

- Ⅱ 森林中第一棵树的子树森林；

- Ⅲ 森林中其他树构成的森林。

**(2)先序遍历**：即依次从左到右对森林中的每一棵树**进行先根遍历**。

- 访问森林中第一棵树的根结点；
- **先序遍历**森林中第一棵树的子树森林；
- **先序遍历**森林中（除了第一棵树之外）其余树构成的森林。

**(3)中序遍历**：即依次从左到右对森林中的每一棵树**进行后根遍历**。

- **中序遍历**森林中第一颗树的子树森林；
- 访问森林中第一棵树的根节点；
- **中序遍历**森林中（除第一棵树之外）其余树构成的森林。

![森林的遍历](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201028113853658.png)



## 8. 哈夫曼树及其应用

### 8.1. 哈夫曼树的概念

**路径**：从树中一个结点到另一个结点之间的**分支**构成这两个结点间的路径。

**结点的路径长度**：两结点间路径上的**分支数**。

**树的路径长度**：从树根到每一个结点的**路径长度之和**。记作：TL。

- **结点数目相同的二叉树中，完全二叉树是路径长度最短的二叉树，反之不对**。

![结点路径长度](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201029215738493.png)

`TL(a) = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 = 20`。

`TL(b) = 1 + 1 + 2 + 2 + 2 + 2 + 3 + 3 = 16 `。

**权**：将树中结点赋予一个有某种含义的值。

**结点的带权路径长度**：从根结点到该结点之间的路径长度与该结点的权的乘积。

**树的带权路径长度**：树中**所有叶子结点**的带权路径长度之和。记作：`WPL(Weighted Path Length)`。

![树的带权路径长度](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201029221239562.png)



**哈夫曼树**：最优树。带权路径长度(WPL)最短的树。

注："带权路径长度最短"是在"度相同"的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等。

**哈夫曼树**：最优二叉树。带权路径长度(WPL)最短的树。

![哈夫曼树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201029222304764.png)



### 8.2. 构造哈夫曼树

![哈夫曼算法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201029223726545.png)

**哈夫曼树的特点**：

- n个叶子结点的哈夫曼中共有`2n-1`个结点。
- 哈夫曼树的d结点的度为0或2，没有度为1的结点。

- 包含n棵树的森林要经过`n-1`次合并才能形成哈夫曼树，共产生`n-1`个新结点。且这`n-1`个新结点都是具有两个孩子的分支结点。



### 8.3. 哈夫曼算法

**(1)结点类型定义**

```c
/**
* 使用顺序存储结构——一维数组
* 定义结点
*/
typedef struct {
    int weight;
    int parent;
    int lchild;
    int rchild;
} HuffmanTreeNode;
```



**(2)实现哈夫曼树**

![哈夫曼树的实现](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201029224911852.png)



**(3)算法**

- 初始化哈夫曼树：`lchild = rchild = 0`；
- 初始化n个叶子结点：初始化`[1....n]`的权值；
- 进行以下n-1次合并，依次产生n-1个新结点`HT[i], i = n+1...2n-1`：
  - Ⅰ在`HT[1...i-1]`中选两个未被选过(parent == 0)的weight最小的两个结点HT[s1]和HT[s2]，s1、s2为两个最小结点的下标；
  - Ⅱ修改HT[s1]和HT[s2]的parent值：`HT[s1].parent = i; HT[s2].parent = i`；
  - Ⅲ修改新产生的HT[i]：`HT[i].lchild = s1; HT[i].rchild = s2; HT[i].weight = HT[s1].weight + HT[s2].weight`；

```C
void createHuffmanTree(HuffmanTreeNode* HT, int n) {
    if(n <= 1) return;
    int m = 2 * n - 1;                // 哈夫曼树结点总数 n + n - 1 = 2n - 1
    
    // 数组的0号单元没有用，HT[m]表示根结点
    HT = (HuffmanTreeNode*)malloc(sizeof(HuffmanTreeNode) * (m + 1));
    
    // 将整个数组初始化
    for(int i = 1; i <= m; i++) {
        HT[i].lchild = 0;
        HT[i].rchild = 0;
        HT[i].parent = 0;
    }
    
    // 输入前n个元素的weight值
    for(int i = 1; i <= n; i++) scanf("%d", &HT[i].weight);
    
    // ~ ~ ~ ~ ~ ~ ~ ~ 初始化结束 下面开始建立哈夫曼树 ~ ~ ~ ~ ~ ~ ~ ~ 
    int s1 = 0;
    int s2 = 0;
    for(int i = n + 1; i <= m; i++) {
        // 在HT[k](1 ≤ k ≤ i-1)中查找权值最小两个结点(s1和s2表示下标)
        select(HT, i-1, &s1, &s2);
        
        // 为两个权值最小的结点设置parent
        HT[s1].parent = i;
        HT[s2].parent = i;
        
        // 为新构造的结点设置lchild和rchild
        HT[i].lchild = s1;
        HT[i].rchild = s2;
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    } 
}
```



### 8.4. 哈夫曼编码

> 构造哈夫曼编码的方法

![哈夫曼编码](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201030174451906.png)



> 哈弗编码例题

![例题](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201030175259454.png)



> 哈夫曼编码算法实现

![哈夫曼编码算法实现](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201030194312748.png)

```c++
typedef struct {
    int weight;
    int parent;
    int lchild;
    int rchild;
} HuffmanTreeNode;

/**
* 构建哈夫曼编码
* @Param HT 哈夫曼树(一维数组的指针)
* @Param HC 存放哈夫曼编码的字符数组
* @Param n  哈夫曼树有效结点数量
*/
void createHuffmanCode(HuffmanTreeNode* HT, HuffmanCode &HC, int n) {
    Hc = new char* [n+1];                             // 最后保存的哈夫曼编码数组
    cd = new char[n];                                 // 临时一维字符数组
    cd[n-1] = '\0';                                   // 临时一维字符数组最后一位为'\0'
    for(int i = 1; i <= n; i++) {
        int start = n -1;                             // 临时一维字符数组的下标
        int c = i;                                    // 孩子
        int f = HT[i].parent;                         // 双亲
        
        // 从叶子结点一直向上回溯,直到根结点
        while(f != 0) {
            start--;                            // 回溯一次，临时一维字符数组指针向前移动一次
            
            // 判断当前的i(c)是f的左孩子还是右孩子
            if(HT[f].lchild == c) cd[start] = '0'; 
            else cd[start] == '1';
            
            // 继续向上回溯
            c = f;
            f = HT[f].parent;
        }
        HC[i] = new char[n-start];                    // 为字符数组的第i行开辟空间
        strcpy(HC[i], &cd[start]);                    // 将临时一维字符数组复制到指定位置
    }
    free cd;
}
```





# 第六章、图

> 回顾：数据的逻辑结构

- 集合：数据元素间除了"**同属于一个集合**"外，无其他关系。
- 线性结构：一对一的关系，**每个数据元素最多只有一个前驱结点和一个后继结点**。如线性表、栈、队列。
- 树形结构：一对多的关系，**每个数据元素可以有一个前驱结点和多个后继结点**。如树，其中根结点没有前驱，叶子结点没有后继。
- 图形结构：多对多的关系，**每个数据元素可以多个前驱结点和多个后继结点**。



## 1. 图的定义和术语

**图**：G = (V,E)

- V：顶点(数据元素)的**有穷非空**集合。
- E：边的**有穷**集合。

**无向图**：每条边都是无方向的图。

**有向图**：每条边都是有方向的图。

**完全图**：图中任意两个顶点**都有一条边**相连。

![完全图](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201022230700854.png)

**稀疏图**：有很少边或弧的图(e < nlogn)。其中n代表顶点的数量。

**稠密图**：有较多边或弧的图。

**网**：边/弧带权的图。

**邻接**：若两个顶点之间有边/弧相连，称这两个顶点邻接，反之则不邻接。

- 存在(vi,vj)，则称vi和vj**互为邻接点**。
- 存在<vi,vj>，则称vi**邻接到**vj，vj**邻接于**vi。

**关联(依附)**：边/弧与顶点之间的关系。

- 存在(vi,vj)/<vi,vj>，则称该边/弧**关联于**vi和vj。

**顶点的度**：与该顶点相关联的边的数目，记为`TD(v)`。**在有向图中，顶点的度 = 入读 + 出度**。

![顶点的度](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201022232234519.png)

**路径**：接续成的**顶点序列**。

**路径长度**：路径上边或弧的数目/权值之和。

**回路(环)**：第一个顶点和最后一个顶点相同的**路径**。

**简单路径**：除路径起点和终点**可以相同**外，其余顶点均不相同的路径。

**简单回路(简单环)**：除路径起点和终点**相同**外，其余顶点均不相同的路径。

![简单路径](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201022233714878.png)

**连通图(强连通图)**：在无(有)向图`G = (V,{E})`中，如果对任何两个顶点 v、u 都存在从 v 到 u 的路径，则称G是连通图(强连通图)。 

![连通图](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201022234500429.png)

**权和网**：

- 图中边或弧所具有的相关数称为**权**。表明从一个顶点到另一个顶点的距离或耗费。
- 带权的图称为**网**。

**子图**：设有两个图`G = (V,{E})、G1 = (V1,{E1})`，若 `V1 ∈ V 且 E1 ∈ E`，则称G1是G的子图。

![子图](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201022235232492.png)

**连通分量**：

- 无向图G的**极大连通子图**称为G的连通分量。
- **极大连通子图**：该子图是G的连通子图，将G的任何不在该子图中的顶点加入，子图不再连通。

![连通分量](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201022235819969.png)

**强连通分量**：

- 有向图G的**极大强连通子图**称为G的强连通分量。
- **极大强连通子图**：该子图是G的强连通子图，将G的任何不在该子图中的顶点加入，子图不再强连通。

![强连通分量](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201023000259871.png)

**极小连通子图**：该子图是G的连通子图，**在该子图中删除任何一条边**，子图不再连通。

**生成树**：包含无向图G所有顶点的极小连通子图。

![生成树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201023000755397.png)

## 2. 图的存储结构

### 2.1. 邻接矩阵

**图的逻辑结构是：多对多的关系。图没有顺序存储结构，但是可以借助二维数组表示元素间的关系。**

> 无向图的邻接矩阵

建立一个**顶点表(记录各个顶点的信息)** 和一个**邻接矩阵(表示各个顶点之间的关系)**。

![无向图邻接矩阵](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201023103237332.png)



> 有向图的邻接矩阵

![有向图的邻接矩阵](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201023103844681.png)



> 网(即有权图)的邻接矩阵

![网的邻接矩阵](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201023104239843.png)



> 邻接矩阵的存储表示

**(1) 用两个数组分别存储顶点表和邻接矩阵**。

```c
#define MaxInt 32767                          // 表示极大值,即∞
#define MaxVexsNum 100                        // 最大顶点数
typedef char VertexType;                      // 设顶点的数据类型为字符型
typedef int ArcType;                          // 设边的权值类型为整型，若不是带权图用0和1表示

typedef struct {
    VertexType vexs[MaxVexsNum];              // 顶点表
    ArcType arcs[MaxVexsNum][MaxVexsNum];     // 邻接矩阵
    int vexnum;                               // 图的当前顶点数
    int arcnum;                               // 图的边数
} AMGraph;                                    // Adjacency Matrix Graph
```

**(2) 采用邻接矩阵表示法创建无向网**

算法：

- 输入**总顶点数和总边数**。
- 依次输入**顶点的信息存入顶点表**中。
- **初始化邻接矩阵**，使每个权值初始化为极大值。
- 构造邻接矩阵。

```c++
/**
* Undirected Network 无向网
* &表示引用 不是取地址运算
*/
Status createUND(AMGraph &G) { 
    // 1.输入总顶点数和总边数并存储
    cin >> G.vexnum >> G.arcnum;              // 输入顶点数目和总边数
    
    // 2.初始化顶点表
    for(int i = 0; i < G.vexnum; i++) {
        cin >> G.vexs[i];                     // 依次输入顶点信息
    }
    
    // 3.初始化邻接矩阵
    for(int i = 0; i < G.vexnum; i++) {
        for(int j = 0; j < G.vexnum; j++) {
            G.arcs[i][j] = MaxInt;            // 边的权值均设置为最大值
        }
    }
    
    // 4.构造邻接矩阵
    for(int k = 0; k < G.arcnum; k++) {
        cin >> v1 >> v2 >> w;                 // 输入一条边所依附的顶点及边的权值
        i = LocateVertex(G, v1);
        j = LocateVertex(G, v2);              // 确定v1和v2在G中的位置
        G.arcs[i][j] = w;                     // 边<v1, v2>的权值置为w
        G.arcs[j][i] = G.arcs[i][j];          // 置<v1, v2>的对称边<v2, v1>的权值为w
    }
    
    return OK;
}

/**
* 在顶点表中查找顶点u的下标，存在则返回顶点表中的下标;否则返回-1
*/
int LocateVertex(AMGraph G, VertexType u) {
    for(int i = 0; i < G.vexnum; i++) {
        if(u == G.vexs[i]) return i;
    }
    return -1;
}
```

**(3)采用邻接矩阵表示法创建无向图、有向网、有向图**

![无向图、有向网、有向图](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201023141124607.png)



> 邻接矩阵存储图的优点和缺点

**优点**：

- 直观、简单、好理解。
- 方便检查任一对顶点之间是否存在边。
- 方便找任一顶点的所有"邻接点"(有边直接相连的顶点)。
- 方便计算任一顶点的"度"(从该点出发的边数为出度，指向该点的边数为入度)。

**缺点**：

- 不便于增加和删除顶点。
- 浪费空间——存稀疏图有大量无效元素。
  - 对于稠密图(特别是完全图)还是很合算的。
- 浪费时间——统计稀疏图中一共有多少条边。

### 2.2. 邻接表

> 邻接表表示法

![邻接表表示法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201023182938184.png)



> 无向图的邻接表

![无向图的邻接表](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201023183730580.png)



> 有向图的邻接表

**邻接表和逆邻接表**

![邻接表和逆邻接表](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201023184550956.png)



> 图的邻接表存储表示

**(1)定义邻接表的表头结点**

```c
/**
* 说明：AdjList v; 等价于 vNode v[MVNum];
*/
typedef struct _vnode {
    VertexType data;              // 顶点信息
    ArcNode* firstarc;            // 指向第一条依附该顶点的边的指针
} vNode, AdjList[MVNum];          // AdjList表示邻接表
```

**(2)定义邻接表的边(弧)结点**

```c
#define MVNum 100                 // 最大顶点数       
typedef struct _arcnode {
    int adjvex;                   // 该边所指向的顶点的下标
    struct _arcnode* nextarc;     // 指向下一条边的指针
    OtherInfo info;               // 和边相关的信息(权重)
} ArcNode;
```

**(3)图的结构定义**

```c
typedef struct {
    AdjList vertices;             // vertices --- vertex的复数
    int vexnum;                   // 图的当前顶点数
    int arcnum;                   // 图的边数
} ALGraph;
```



**(4)采用邻接表表示法创建无向图**

算法：

- 输入**总顶点数和总边数**。
- 建立**顶点表(邻接表的表头数组)**：
  - 依次输入点的信息**存入顶点表**中；
  - 使每个表头结点的**指针域初始化为NULL**。

- 创建邻接表：
  - 依次输入每条边依附的两个顶点；
  - 确定两个顶点的序号`i、j`，建立边结点；
  - 将此边结点分别插入到`vi、vj`对应的两个边链表的头部(头插法)。

```c++
/**
* 采用邻接表表示法创建无向图G
*/
Status createUDG(ALGraph &G) {
    cin >> G.vexnum >> G.arcnum;               // 输入图的顶点数和边数并保存
    
    // 输入各点构造表头结点
    for(int i = 0; i < G.vexnum; i++) {
        cin >> G.vertices[i].data;             // 输入顶点的值
        G.vertices[i].firstarc = NULL;         // 初始化表头结点的指针域为NULL
    }
    
    // 输入各边构造邻接表(头插法)
    for(int k = 0; k < G.arcnum; k++) {
        cin >> v1 >> v2;
        int i = locateVertex(G, v1);
        int j = locateVertex(G, v2);
        
        ArcNode* p1 = (ArcNode*)malloc(sizeof(ArcNode));   // 创建新的结点
        p1->adjvex = j;                                    // 邻接点序号为j
        p1->nextarc = G.vertices[i].firstarc;              // 6666666
        G.vertices[i].firstarc = p1;                       // 将新结点p1插入结点vi的边表头部
        
        // 由于是无向图所以还要对称着插入一次(有向图这部分代码直接不用写了)
        ArcNode* p2 = (ArcNode*)malloc(sizeof(ArcNode));
        p2->adjvex = i;
        p2->nextarc = G.vertices[j].firstarc;
        G.vertices[j].firstarc = p2;
    } 
    return OK;
}
```



> 邻接表的特点

- 方便找任一顶点的所有"邻接点"。
- 节约稀疏图的空间：
  - 需要N个头指针 + 2E个结点(每个结点至少两个域)。
- 方便计算任一顶点的"度"？？
  - 对于无向图：是；
  - 对于有向图：邻接表(计算出度) + 逆邻接表(计算入度)。

- 不方便检查任一对顶点间是否存在边。



> 邻接矩阵和邻接表表示法之间的关系

![邻接矩阵和邻接表的关系](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201023201835807.png)

**(1)联系**：邻接表中每个链表对于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。

**(2)区别**：

- 对于任一确定的无向图，**邻接矩阵是唯一的(行列号与顶点编号一致)，但是邻接表不唯一(链表次序与顶点编号无关)**。
- 邻接矩阵的空间复杂度为`O(n2)`，而邻接表的空间复杂度为`O(n+e)`。

**(3)用途**：邻接矩阵多用于稠密图；而邻接表都用于稀疏图。



![为什么要有十字链表和邻接多重表](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201023225005147.png)

### 2.3. 十字链表

**十字链表可以看成：将有向图的邻接表和逆邻接表结合起来形成的一种链表。**

![十字链表](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201023230157621.png)

### 2.4. 邻接多重表

```c
typedef char ElemTyde;

// ivex,jvex该边依附的两个顶点在表头中的位置
typedef struct _arcnode {
    int mark;                     // 标志位
    int ivex;
    struct _arcnode* ilink;       // 依附于ivex的下一条边
    int jvex;
    struct _arcnode* jlink;       // 依附于jvex的下一条边
} ArcNode;

typedef struct {
    ElemTyde data;                // 与顶点有关的信息
    ArcNode* firstarc;            // 指向第一条依附于顶点的边
} VNode;
```



![邻接多重表](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201023231257565.png)

## 3. 图的遍历

**遍历定义**：从已给的连通图中某一顶点出发，沿着一些边访遍全图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历。

**遍历实质**：找每个顶点的邻接点的过程。 

### 3.1. 深度优先遍历(DFS)

**深度优先遍历：一条路走到黑。**

![深度优先遍历](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024000704373.png)



> 深度优先遍历——邻接矩阵上的遍历算法

![深度优先遍历](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024001746949.png)

```c
#define MaxVexsNum 100
typedef char VertexType;
typedef int ArcType;

/**
* 定义邻接矩阵
*/
typedef struct {
    VertexType vexs[MaxVexsNum];
    ArcType arcs[MaxVexsNum][MaxVexsNum];
    int vexnum;
    int arcnum;
} AMGraph;

/**
* 辅助数组：标记顶点是否被访问过
*/
int visited[MaxVexsNum];

/**
* 邻接矩阵上的深度优先算法
* @Param G表示为邻接矩阵类型
* @Param v表示访问第v个顶点,赋值时表示起始顶点
*/
void DFS(AMGraph G, int v) {
    cout << v;                                // 输出起始顶点
    visited[v] = 1;                           // 辅助数组记录 1表示该顶点被访问过了
    
    // 依次检查邻接矩阵v所在的行(w表示邻接矩阵的列)
    for(int w = 0; w < G.vexnum; w++) {
        // 邻接矩阵上的值为1 并且 在辅助数组中没有被访问过, 就对该点继续DFS
        if(G.arcs[v][w] != 0 && !visited[W]) DFS(G, w);
    }
}
```



> 深度优先遍历——邻接表上的遍历算法

```c
#define MVNum 100
typedef char VertexType;

/**
* 定义边结点
*/
typedef struct _arcnode {
    int adjvex;
    struct _arcnode* nextarc;
} ArcNode;

/**
* 定义顶点
*/
typedef struct _vnode {
    VertexType data;
    ArcNode* firstarc;
} VNode, AdjList[MVNum];

/**
* 定义邻接表
*/
typedef struct {
    AdjList vertices;
    int vexnum;
    int arcnum;
} ALGraph;

/**
* 辅助数组
*/
int visited[MVNum];

/**
* 邻接表的深度优先遍历
* @Param G代表邻接表
* @Param v代表起点编号
*/
void DFS(ALGraph* G, int v) {
    ArcNode* P;
    
    cout << v;                                       // 输出起始顶点
    visited[v] = 1;                                  // 辅助数组记录 1表示该顶点被访问过了
    p = G->vertices[v].firstarc;                     // p指向顶点v的第一条边
    while(p) {
        // 如果顶点未被访问,则递归访问它
        if(visited[p->adjvex] == 0) DFS(G, p->adjvex);
        p = p->nextarc;
    }
}
```



> DFS算法分析

- 用**邻接矩阵**来表示图，遍历图中每一个顶点都要从头扫描该顶点所在行，时间复杂度为`O(n2)`。

- 用**邻接矩阵**来表示图，虽然有 2e 个表结点，但只需要扫描 e 个结点即可完成遍历，时间复杂度为`O(n+e)`。

- 稠密图适于在邻接矩阵上进行深度优先遍历；稀疏图适于在邻接表上进行深度优先遍历。

### 3.2. 广度优先遍历(BFS)

**广度优先遍历：和树的层序遍历非常相似**。

![广度优先遍历](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024125402224.png)



> 广度优先遍历——邻接矩阵上的遍历算法

**需要借助队列和辅助数组实现**。

![广度优先遍历](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024130840216.png)

```c
#define MVNum 100
typedef char VertexType;

/**
* 定义边结点
*/
typedef struct _arcnode {
    int adjvex;
    struct _arcnode* nextarc;
} ArcNode;

/**
* 定义顶点
*/
typedef struct {
    VertexType data;
    ArcNode* firstarc;
} VNode, AdjList[MVNum];

/**
* 定义邻接表
*/
typedef struct {
    AdjList vertices;
    int vexnum;
    int arcnum;
} ALGraph;

/**
* 辅助数组
*/
int visited[MVNum];

/**
* 邻接表的广度优先遍历(非递归算法)
* @Param G代表邻接表
* @Param v代表起点编号
*/
void BFS(ALGraph G, int v) {
    ArcNode* p;
    cout << v;                                  // 访问第v个顶点
    visited[v] = 1;                             // 更新辅助数组
    initQueue(Q);                               // 辅助队列Q初始化，默认为空
    enQueue(Q, v);                              // v进队
    
    // 队列不为空，则出队
    while(!isEmpty(Q)) {
        int j = deQueue(Q);                     // 队头元素出队
        p = G.vertices[j].firstarc;             // p指向出队顶点j的第一条边
        
        // 将p的所有邻接点中未被访问的入队
        while(p) {
            if(visited[p->adjvex] == 0) {       // 当前邻接点未被访问，则入队
                cout << p->adjvex;
                visited[p->adjvex] = 1;
                enQueue(Q, p->adjvex);
            }
            p = p->nextarc;
        }
    }
}
```



> BFS算法分析

- 如果使用**邻接矩阵**，则BFS对于每一个被访问到的顶点，都要循环检测矩阵中的整整一行(n个元素)，时间复杂度为`O(n2)`。

- 用**邻接表**来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为`O(n+e)`。



> DFS和BFS算法效率比较

- 空间复杂度相同，都是`O(n)`(借助了栈或者是队列)。
- **时间复杂度只与存储结构(邻接矩阵或邻接表)有关，而与搜索路径无关。**

## 4. 图的应用

### 4.1. 生成树

> 概念回顾——生成树

![生成树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024144541963.png)

**生成树：**

- 包含无向图G所有顶点的极小连通子图。即：所有顶点均由边连接在一起，但**不存在回路的图**。
- **一个图可以有许多棵不同的生成树**。

**所有生成树具有以下共同特点**：

- 生成树的顶点个数与图的**顶点个数相同**。
- 生成树是图的**极小连通子图**，去掉一条边则非连通。
- **在生成树中再加一条边必然形成回路**。
- 一个有n个顶点的连通图的生成树有`n-1`条边。
- 含有n个顶点`n-1`条边的图不一定是生成树。
- 生成树中任意两个顶点间的**路径是唯一**的。



> 无向图的生成树

![遍历算法形成生成树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024145256572.png)

深度优先遍历算法——深度优先生成树。

广度优先遍历算法——广度优先生成树。



### 4.2. 最小生成树

![最小生成树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024145819871.png)



> MST性质

![MST](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024151020965.png)

**MST性质解释**

- 在生成树的构造过程中，图中n个顶点分属两个集合：
  - 已落在生成树上的顶点集(U)。
  - 尚未落在生成树上的顶点集(V-U)。

- 接下来则应在所有连通 `U` 中顶点和 `V-U` 中顶点的边中**选取权值最小的边**。

![MST性质](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024151734872.png)



> 普利姆(Prim)算法：{U}和{V-U}中选取权值最小的边，MST性质的应用。从顶点出发

![Prim算法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024152525420.png)



> 克鲁斯卡尔(Kruskal)算法：从边出发

![Kruskal算法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024153319587.png)



> Prim和Kruskal之间的比较

|   算法名   |         Prim         |        Kruskal        |
| :--------: | :------------------: | :-------------------: |
|  算法思想  |        选择点        |        选择边         |
| 时间复杂度 | **O(n2)(n为顶点数)** | **O(eloge)(e为边数)** |
|  适用范围  |        稠密图        |        稀疏图         |



### 4.3. 最短路径

**最短路径**：

- 在**有向网中**A点(源点)到达B点(终点)的多条路径中，寻找一条**各边权值之和最小的路径**，即最短路径。
- 最短路径与最小生成树不同，最短路径上不一定要包含n个顶点，也不一定包含n-1条边。

> 最短路径的两类问题

**(1)第一类问题：两点间最短路径——Dijkstra(迪杰斯特拉)算法**。

![两点间最短路径](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024154430571.png)



**(2)第二类问题：求图中各顶点间最短路径——Floyd(弗洛伊德)算法**。

![某源点到其它各点最短路径](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024154729534.png)



> Dijkstra算法(和prim类似)：按路径长度递增次序产生最短路径

![Dijkstra算法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024201501158.png)

![Dijkstra算法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024202554243.png)



> Floyd算法：求图中各顶点间的路径 

![Floyd](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024205139870.png)



### 4.4. 拓扑排序

> 有向无环图及其应用

**(1)有向无环图？**

![有向无环图](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/2020102421194133.png)

**有向无环图**：无环的有向图，简称**DAG图(Directed Acyclic Graph)**。



**(2)AOV网和AOE网**

![AOV网和AOE网](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024212247558.png)

**AOV网：拓扑排序**。

**AOE网：关键路径**。



**(3)AOV网的特点**

![AOV网特点](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024213247229.png)



> 拓扑排序

**(1)拓扑排序的方法**

**拓扑排序**：在AOV网没有回路的前提下，我们将全部活动排列成一个线性序列，使得AOV网中有弧`<i, j>`存在，则在这个序列中，`i `一定排在 `j` 的前面，具有这种性质的线性序列称为**拓扑有序序列**，相应的拓扑有序排序的算法称为**拓扑排序**。

![拓扑排序的方法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024214012609.png)



**(2)拓扑排序的重要应用：检测AOV网中是否存在环**

![检查AOV网中是否存在环](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024214533102.png)



### 4.5. 关键路径

**(1)AOE网各部分的意思**

- 把工程计划表示为**边表示活动的网络，即AOE网**；
- 用顶点表示**事件**；
- 弧表示**活动**；
- 弧的权代表**活动时间**。

**(2)对于AOE网我们关心的两个问题**

- Ⅰ 完成整项工程至少需要多少时间？
- Ⅱ 哪些活动是影响工程进度的关键？

以上两个问题都是关键路径问题。

**关键路径**——路径长度最长的路径。

**路径长度**——路径上各持续时间之和。



> 确定关键路径

**(1)定义4个重要的描述量**

![关键路径](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024231123166.png)



**(2)计算事件的最早发生事件`ve(v1)`和最迟发生事件`vl(v2)`**

![事件的最早和最晚发生时间](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024233345738.png)



**(3)如何找`l(i) == e(i)`的关键活动**？

![活动的最早开始时间和最晚开始时间](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201024233628370.png)



**(4)求关键路径的步骤**

![关键路径](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201025000736950.png)

#  第七章、查找

## 1. 线性表的查找

### 1.1. 顺序查找

**应用范围**：

- 顺序表或线性表表示的**静态查找表**。
- 表内元素之间**无序**。

**顺序表的表示**：

```c
typedef struct {
    KeyType key;         // 关键字域
    ValueType val;       // 值域
} ElemType;

typedef struct {
    ElemType* R;         // 表基础地址
    int length;          // 表长
} SqList;

SqList ST;               // 定义顺序表ST
```



**在顺序表ST中查找值为*key*的数据元素**：

```c
int search_seq(SqList ST, KeyType key) {
    for(int i = ST.length - 1; i >= 0; i--) {
        if(ST.R[i].key == key) return i;
    }
    return -1;
}

// 哨兵
int search_seq(SqList ST, KeyType key) {
    ST.R[0].key = key;
    for(int i = ST.lengt - 1; ST.R[i].key != key; i--);
    return i;
}
```

![顺序查找](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201106192331705.png)

**比较次数与key的位置有关**：

- 查找第 *i* 个元素，需要比较 *n-i+1* 次。
- 查找失败，需要比较 *n+1* 次。
- **时间复杂度**：`O(n)`。
- **空间复杂度**：一个辅助空间用来存放哨兵，`O(1)`。 



### 1.2. 二分查找

**二分查找前提**：必须是有序序列。

```c
// 1. 普通二分查找算法
int search_bin(SqList ST, KeyType key) {
	int low = 0;
    int high = ST.length - 1;
    while(low <= high) {
        int mid = (low + high) / 2;
        if(ST.R[mid].key == key) return mid;
        else if(key < ST.R[mid].key) high = mid - 1;
        else low = mid + 1;
    }
    return -1;
}

// 2. 二分查找递归算法
int search_bin(SqList ST, KeyType key, int low, int high) {
    if(low > high) return -1;
    int mid = (low + high) / 2;
    if(key == ST.R[mid]) return mid;
    if(key < ST.R[mid]) return search_bin(ST, key, low, mid-1);
    if(key > ST.R[mid]) return search_bin(ST, key, mid+1, high);
}
```



**二分查找的性能分析—判定树**。

![平均查找长度](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201106194736307.png)

**时间复杂度**：`O(logn)`。



### 1.3. 分块查找

**分块查找也叫做索引顺序查找**。

**分块查找的条件**：

1. 将表分成几块，且表 或者有序，或者**分块有序**；分块有序是指：若 *i < j*，则第 *j* 块中所有记录的关键字均大于第 *i* 块中最大的关键字。
2. 建立"索引表"（每个结点含有**最大关键字域**和指向本块第一个结点的指针，且按关键字有序）。

![分块查找](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/2020110719125768.png)



**分块查找的查找效率**：查找效率 = 对索引表查找的ASL + 对块查找的ASL。



### 1.4. 查找方法的比较

![线性表查找的比较](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201107191535327.png)



## 2. 树表的查找

### 2.1. BST

**定义**：`BST`可以是空树，或者满足如下性质的二叉树，

1. 若其**左子树非空**，则左子树上所有结点的值均**小于根结点**的值；
2. 若其**右子树非空**，则左子树上所有结点的值均**大于等于根结点**的值；
3. **其左右子树本身又各是一颗二叉排序树**。



**BST的存储结构**：

```c
// 定义数据类型
typedef struct {
    KeyType key;
    ValueType value;
} ElemType;

// 定义BST结点
typedef struct _node {
	ElemType data;
    struct _node* lchild;
    struct _node* rchild;
} Node;

// 定义BST
typedef struct {
   Node* root;
   int size;
} BST;
```



**算法思想**：

- 若查找的关键字等于根结点，成功；
- 否则：
  - 若小于根结点，查其左子树；
  - 若大于根结点，查其右子树；
- 在左右子树上的操作类似。

```c
Node* search(Node* x, KeyType key) {
	if(x == NULL) return x;
    if(x->data == key) return x;
    if(key < x->data) return search(x->lchild, key);
    if(key > x->data) return search(x->rchild, key);
}
```



**BST的查找分析**：

![BST查找分析](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201107200008296.png)

含有 *n* 个结点的二叉排序树的**平均查找长度和树的形态有关**。



**BST的插入操作**：

```c
// 插入
Node* put(Node* x, KeyType key, ValueType value) {
    if(x == NULL) {
        x = (Node*)malloc(sizeof(Node));
        x->data = key;
        x->lchild = NULL;
        x->rchild = NULL;
        return x;
    }
    if(key < x->data)  x->left = put(x->left, key, value);
    else if(key > x->data) x->right = put(x->right, key, value);
    else x->value = value;
    return x;
}
```



**BST的删除操作**：

第一种情况是，**如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null**。

第二种情况是，**如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了**。

第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。**我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点**。

```c
/**
* 删除二叉查找树的结点
*/
void deleteNode(Bst* bst, int key) {
	Node* p = bst->root;                      // p指向要删除的节点，初始化指向根结点
	Node* pp = NULL;                          // pp记录的是p的父结点
	while(p != NULL && p->key != key) {       // 遍历二叉树寻找目标结点
		pp = p;
		if(key > p->key)
			p = p->right;
		else
			p = p->left;
	}

	if (p == NULL) return ;                   // 没有找到

	// 1.要删除的结点有两个子节点
	if(p->left != NULL && p->right != NULL) { // 查找右子树的最小结点
		Node* minP = p->right;                // 初始化minP，指向右子树的根结点
		Node* minPP = p;                      // minPP表示minP的父结点
		while(minP->left != NULL) {
			minPP = minP;
			minP = minP->left;
		}

		p->key = minP->key;                   // 将minP的数据替换到p中
		p->value = minP->value;
		p = minP;                             // 下面就变成删除minP了
		pp = minPP;                           // 这种类型属于删除pp的左子结点(p无子结点)
	}

	// 2.要删除的结点是叶子结点或仅有一个子结点
	Node* child;                              // p的子结点
	if(p->left != NULL)                       // p只有左子结点
		child = p->left;           
	else if(p->right != NULL)                 // p只有右子结点
		child = p->right;
	else                                      // p无子结点
		child = NULL;

	if(pp == NULL)
		bst->root = child;                    // 删除的p是根结点
	else if (pp->left == p)
		pp->left = child;                     // 删除的p是pp的左子结点
	else
		pp->right = child;                    // 删除的p是pp的右子结点
}
```

**总结：其实BST中删除结点，表面上是三种情况，本质上就两种情况。其一，目标结点只有左子结点或右子结点；其二，目标结点没有子结点。一定要注意对目标结点有左右子结点的情况进行转化**。



### 2.2. 平衡二叉树

**平衡二叉树**：

- 又称 *AVL* 树。
- 一颗平衡二叉树或者是空树，或者是具有以下性质的**二叉排序树**：
  - **左子树与右子树的高度之差的绝对值小于等于1**；
  - 左子树和右子树也是平衡二叉树。

**平衡因子**：为了方便起见，给每个结点附加一个平衡因子，给出**该结点左子树与右子树的高度差**。

**平衡因子 = 结点左子树的高度 - 结点右子树的高度**。平衡二叉树上所有结点的平衡因子只能是 -1 、0 或 1。

![平衡二叉树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201108165935331.png)





> 平衡调整的四种类型

![平衡调整的四种类型](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201108170653900.png)

![平衡二叉树的调整](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201108171834539.png)

![平衡二叉树](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201108172458556.png)





## 3. 散列表的查找

### 3.1. 散列函数

> 散列函数的构造方法

**(1)除留余数法**。

![除留余数法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201108185940279.png)



### 3.2. 处理冲突的方法

> 开放地址法

**基本思想**：有冲突时就去**寻找下一个空的散列地址**，只要散列表足够大，空的散列地址总能找到，并将数据元素插入。

![开放地址法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201108190313815.png)



**(1)线性探测法**。

例：关键码集为 {47，7，29，11，16，92，22，8，3}，散列表的长度 m = 11；散列函数为 *Hash(key) = key mod 11* ；拟用线性探测法解决冲突。

![线性探测法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201108191257782.png)



**(2)二次探测法**。

![二次探测法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201108191902897.png)



> 链地址法

**基本思想**：相同散列地址的记录链成一单链表，**m个散列地址就设m个单链表**，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。

![链地址法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201108192351276.png)



### 3.3. 散列表的查找

![线性探测法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201108194515550.png)

![连地址法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201108194652894.png)



# 第八章、排序

**排序方法的分类**：

- **按数据存储介质**：内部排序和外部排序。
  - **内部排序**：数据量不大、数据在内存，无需内外存交换数据。
  - **外部排序**：数据量较大、数据在外存（文件排序）。外部排序时，要将数据分批调入内存来排序，中间结果还要及时存放外存，显然外部排序就很复杂。
- **按比较器个数**：串行排序和并行排序。
  - **串行排序**：单处理器（同一时刻比较一对元素）。
  - **并行排序**：多处理器（同一时刻比较多对元素）。
- **按主要操作**：比较排序和基数排序。
  - **比较排序**：插入排序、交换排序、选择排序、归并排序。
  - **基数排序**：不比较元素的大小，仅仅根据元素本身的取值确定其有序位置。
- **按辅助空间**：原地排序和非原地排序。
  - **原地排序**：辅助空间用量为 `O(1)` 的排序方法。
  - **非原地排序**：辅助空间用量超过 `O(1)` 的排序方法
- **按稳定性**：稳定排序和非稳定排序。
  - **稳定排序**：能够使任何数值相等的元素，排序后相对次序不变。
  - **非稳定排序**：不是稳定排序的方法。
- **按自然性**：自然排序和非自然排序。
  - **自然排序**：输入数据越有序，排序的速度越快的排序方法。
  - **非自然排序**：不是自然排序的方法。

![稳定性](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201108220130909.png)



**存储结构——顺序存储结构**：

```c
#define MAXSIZE 20
typedef int KeyType;
typedef int ValueType;

// 定义记录的数据类型
typedef struct {
    KeyType key;
    ValueType value;
} RecordType;

// 定义顺序表
typedef struct {
    RecordType r[MAXSIZE];
    int length;
} SqList;
```





## 1. 插入排序

- **顺序法定位插入位置**：直接插入排序。
- **二分法定位插入位置**：二分插入排序。
- **缩小增量多遍插入排序**：希尔排序。



### 1.1. 直接插入排序

```c
/**
* 可以直接类比插入扑克牌
*/
void sort(SqList* list) {
    int* a = list->r;
    int N = list->length;
   
    for(int i = 1; i < N; i++) {
        int temp = a[i];                    // temp来保存当前i位置的值
        int j = i;
        while(j > 0 && temp < a[j - 1]) {
            // 当前temp值比i前面的值都小，就整体后移一位(当前i前面的值都是有序的)
            a[j] = a[j-1];
            j--;
        }
        a[j] = temp;                        // 最后将temp的值插入到合适的位置
    }
}
```

**算法效率分析**：

- 原始数据越接近有序，排序速度越快。最好情况`O(n)`。
- 最坏情况下（输入数据是逆向有序的）。`O(n2)`
- 平均情况下，耗时差不多是最坏情况的一半。`O(n2)`。
- **直接插入排序是稳定排序**。



### 1.2. 折半插入排序

```c
/**
* 折半插入排序
*/
void sort(int a[], int N) {

	int i, temp, low, high, mid;

	for(i = 1; i < N; i++) {
		temp = a[i];
		low = 0;
		high = i - 1;

		// 折半查找确定插入位置：即为low+1的位置
		while(low <= high) {
			mid = (low + high) / 2;
			if(temp < a[mid]) high = mid - 1;
			else low = mid + 1;
		}

		// 将元素后移,腾出位置
		int j = i - 1;
		while(j > low) {
			a[j+1] = a[j];
			j--; 
		}
		a[j] = temp;
	}
}
```

**算法效率分析**：

- 时间复杂度为`O(n2)`。
- 空间复杂度为`O(1)`。
- **折半插入排序是一种稳定的排序方法**。



### 1.3. 希尔排序

**直接插入排序在什么情况下效率比较高**？

- 直接插入排序在**基本有序**时，效率较高。
- 直接插入排序的**记录个数较少**时，效率较高。

**希尔排序的出发点**：直接插入排序比较一次移动一步，希尔排序比较一次移动一大步。



**希尔排序基本思想**：

- 先将整个待排记录序列分割成**若干子序列**，分别进行**直接插入排序**。
- 待整个序列中的记录"**基本有序**"时，再对全体记录进行一次直接插入排序。

![希尔排序](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201109124928252.png)

**希尔排序的特点**：

- 一次移动，移动位置较大，跳跃式地接近排序后的最终位置。
- 最后一次只需要少量移动。
- 增量序列必须是递减的，最后一个必须是1。
- 增量序列应该是互质的。
- **希尔排序是不稳定的排序算法**。

```java
import static com.ymy.sort.utils.SortedUtils.*;

/**
 * 希尔排序
 * [S, H, E, L, L, S, O, R, T, E, X, A, M, p, L, E]
 * 
 * [L, E, E, A, M, H, L, E, S, S, O, L, T, p, X, R]
 * [A, E, E, E, H, L, L, L, M, O, R, S, S, T, X, p]
 */
public class Shell {

    public static void main(String[] args) {
        String[] a = new String[]{"S", "H", "E", "L", "L", "S", "O", "R", "T", "E", "X", "A", "M", "p", "L", "E"};
        sort(a);
    }
    
    public static void sort(Comparable[] a) {
        int N = a.length;
        int h = 1;
        while (h < N / 3) h = 3 * h + 1;
        while (h >= 1) {
            for (int i = h; i < N; i++) {
                for (int j = i; j >= h && less(a[j], a[j - h]); j -= h) {
                    exchange(a, j, j - h);
                }
            }
            h = h / 3;
        }
    }
}
```



## 2. 交换排序

### 2.1. 冒泡排序

![冒泡排序](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201109204451937.png)

**基本思想**：

每趟不断将记录两两比较，并按"前小后大"规则交换。

```c
/**
* 冒泡排序
*/
void sort(int a[], int N) {
	int T = N - 1;                         // 冒泡排序(N-1)趟完成
	int temp;                              // temp 保存交换时的临时变量
	for(int i = 1; i <= T; i++) {
		for(int j = 1; j <= N - i; j++) {  // j <= N-i 后边的大元素就不需要比较了
			if(a[j-1] > a[j]) {
				temp = a[j];
				a[j] = a[j-1];
				a[j-1] = temp;
			}
		}
	}
}

/**
* 算法改进
*/
void sort(int a[], int N) {
	int T = N - 1;                         // 冒泡排序(N-1)趟完成
	int temp;                              // temp 保存交换时的临时变量
	int flag = 1;                          // flag表示是否有交换的标记  
	for(int i = 1; i <= T && flag == 1; i++) {
		flag = 0;
		for(int j = 1; j <= N - i; j++) {  // j <= N-i 后边的大元素就不需要比较了
			if(a[j-1] > a[j]) {
				flag = 1;                  // 发生交换flag设置为1，若本趟没有交换flag保持为0
				temp = a[j];
				a[j] = a[j-1];
				a[j-1] = temp;
			}
		}
	}
}
```

**冒泡排序算法分析**：

- 最好时间复杂度是`O(n)`。
- 最坏时间复杂度为`O(n2)`。
- 平均时间复杂度为`O(n2)`。

### 2.2. 快速排序

**基本思想**：

- 任取一个元素（一般为第一个）为中心；
- 所有比它小的元素一律前放，比它大的元素一律后放，形成左右两个子表；
- 对各子表重新选择中心元素并依此规则调整；
- 直到每个子表的元素只剩一个。

![快速排序](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201109210829310.png)

```c
void sort(int a[], int N) {
	quickSort(a, 0, N - 1);
}

// 快速排序
void quickSort(int a[], int lo, int hi) {
	if(hi <= lo) return;
	int j = partition(a, lo, hi);
	quickSort(a, lo, j - 1);
	quickSort(a, j + 1, hi);
}

// 获取切割点
int partition(int a[], int lo, int hi) {
	int i = lo, j = hi + 1;             // 左右扫描的指针
	int v = a[lo];                      // 切分数组的元素(默认使用第一个)
	while(i < j) {
		while(a[++i] < v) if(i == hi) break;
		while(a[--j] > v) if(j == lo) break;
		if(i >= j) break;
		exch(a, i, j);
	}
	exch(a, lo, j);                     // 将分割的值放到合适的位置 
	return j;
}

// 交换元素 
void exch(int a[], int idx1, int idx2) {
	if(a == NULL) return ;
	int temp = a[idx1];
	a[idx1] = a[idx2];
	a[idx2] = temp;
}
```

**快速排序算法分析**：

- 时间复杂度：`O(nlogn)`。
- 空间复杂度：快速排序不是原地排序，用到了递归需要使用系统栈。平均条件下需要`O(logn)`的栈空间。
- **快速排序不稳定**。
- **快速排序不适于原本有序或基本有序的序列进行排序**。

## 3. 选择排序

### 3.1. 简单选择排序

**基本操作**：

1. 首先通过 *n - 1* 次关键字比较，从 *n* 个记录中找出关键字最小的记录，将它与第一个记录交换；
2. 再通过 *n - 2* 次关键字比较，从 剩余的*n - 1* 个记录中找出关键字最小的记录，将它与第二个记录交换；
3. 重复上述操作，共进行 *n - 1* 趟排序后，排序结束。

![简单选择排序](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201109233742619.png)

```c
void sort(int a[], int N) {
	// 执行 n-1 趟
	for(int i = 1; i <= N-1; i++) {
		// 最小值的下标
		int min = i - 1;
		for(int j = i; j < N; j++) if(a[j] < a[min]) min = j;
		
		// 交换 
		int temp = a[i-1];
		a[i-1] = a[min];
		a[min] = temp;
	}
}
```

**时间复杂度**：

- 记录移动次数：
  - 最好情况：0。
  - 最坏情况：3(n-1)。
- 比较次数：**无论待排序列处于什么状态，选择排序所需进行的"比较次数"相同**。
- **简单选择排序是不稳定的排序**。



### 3.2. 堆排序

**(1)堆的定义**：

![堆的定义](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201109235553181.png)

![堆的定义](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201110000032776.png)



**(2)堆排序基本思想**：

若在输出**堆顶**的最小值（最大值）后，使得剩余 *n - 1* 个元素的序列重新又建成一个堆，则得到的 *n* 个元素的次小值（次大值）...如此反复，便能得到一个有序序列，这个过程称之为堆排序。

**(3)如何在输出堆顶元素后。调整剩余元素为一个新的堆**？

**小根堆**：

1. 输出堆顶元素之后，**以堆中最后一个元素代替(编号最大的元素)**；
2. 然后将根结点值与左、右子树的根结点值进行比较，**并与其小者进行交换**；
3. 重复上述操作，直至叶子结点，将得到新的堆，称这个从堆顶到叶子的调整过程为"筛选"。

```c
/**
* 堆排序
*
* @Param int a[] 数组
* @Param int N   堆中结点数量
*/
void sort(int a[], int N) {
	// 循环建立初始堆
	for(int i = N / 2; i >= 0; i--) {
		heapAdjust(a, i, N);
	}

	// 进行 n-1 次循环完成排序
	for(int i = N - 1; i > 0; i--) {
		// 最后一个元素和第一个元素交换
		int temp = a[i];
		a[i] = a[0];
		a[0] = temp;

		// 筛选 a[0] 结点，得到剩余i个结点的堆
		heapAdjust(a, 0, i);
	}
}

/**
* 堆调整：大根堆
* 小根堆的调整只需要调整如下语句：
* 1. if(child + 1 < N && a[child] > a[child + 1]) child++;
* 2. if(temp <= a[child]) break;
*
* @Param int a[]     数组
* @Param int parent  父节点
* @Param int N       堆中结点的数量
*/
void heapAdjust(int a[], int parent, int N) {

	int temp = a[parent];                       // temp 保存当前父节点
	int child = 2 * parent + 1;                 // 获得左孩子

	while(child < N) {
		// 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点
		if(child + 1 < N && a[child] < a[child + 1]) child++;

		// 如果父结点的值已经大于孩子结点的值，则直接结束
		if(temp >= a[child]) break;

		// 把孩子结点的值赋给父节点
		a[parent] = a[child];
        
        // (1)(2)任意两条语句任取一个都可以实现堆调整
		a[child] = temp;                       // 这句容易理解(1)

		// 选取孩子结点的左孩子结点，继续向下筛选
		parent = child;
		child = 2 * child + 1;
	}

//	a[parent] = temp;                         //  这句赋值次数会变少，但是不好理解(2)
}
```



**(4)堆的建立**

![堆的建立](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201110123108523.png)

```c
for(int i = N / 2; i >= 0; i--) {
    heapAdjust(a, i, N);
}
```



**堆排序算法分析**：

- 初始堆所需要的时间不超过`O(n)`。
- 排序阶段(不含堆初始化)：
  - 一次重新堆化所需时间不超过`O(logn)`；
  - *n - 1* 次循环所需时间不超过`O(nlog)`。
- **堆排序的时间复杂度**：`O(nlogn)`。
- **无论待排序列中的记录是正序还是逆序排列，都不会使堆排序处于"最好"或"最坏"的状态**。

- **堆排序是不稳定的排序方法**。

## 4. 归并排序

![归并排序](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201110125644692.png)

**基本思想**：将两个或者两个以上的有序子序列"归并"为一个有序序列。

```java
/**
 * 归并排序
 */
public class Merge {
    /**
     * 归并需要的额外的数组
     */
    private static Comparable[] aux;

    public static void sort(Comparable[] a) {
        aux = new Comparable[a.length];  // 数组aux初始化
        sort(a, 0, a.length - 1);
    }

    /**
     * 归并排序
     *
     * @param a  目标数组
     * @param lo 开始下标
     * @param hi 结束下标
     */
    private static void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) return; // 递归的出口
        int mid = (lo + hi) >>> 1; // 计算mid中间值
        sort(a, lo, mid); // 将左半边排序
        sort(a, mid + 1, hi); // 将右半边排序
        merge(a, lo, mid, hi); // 归并结果
    }

    /**
     * 原地归并方法
     * 将a[lo...mid]和a[mid+1...hi]归并
     * 前提：a[lo...mid]和a[mid+1...hi]都是有序的！
     * For Example：
     * 0  1  2  3  4  5  6  7    8  9  10 11 12 13 14 15
     * E  E  G  M  O  R  R  S |  A  E  E  L  M  P  T  X
     * 主要比较aux[i]和aux[j]的大小,只要满足less(aux[j],a[i])那么a[k]=aux[j++],
     * 其他情况下就是a[k]=aux[i++];不过当i>mid的时候,就是左边遍历完了,就是a[k]=aux[j++];
     * 右边遍历完了就是a[k]=aux[i++]
     *
     * @param a   目标数组
     * @param lo  开始下标
     * @param mid 中间下标
     * @param hi  结束下标
     */
    private static void merge(Comparable[] a, int lo, int mid, int hi) {
        int i = lo;
        int j = mid + 1;

        // 将a[lo..hi]复制到aux[lo..hi]
        for (int k = lo; k <= hi; k++) {
            aux[k] = a[k];
        }

        // 将aux数组归并到a数组中
        for (int k = lo; k <= hi; k++) {
            if (i > mid)
                a[k] = aux[j++];
            else if (j > hi)
                a[k] = aux[i++];
            else if (less(aux[j], aux[i]))
                a[k] = aux[j++];
            else
                a[k] = aux[i++];
        }
    }
```

 

**归并排序算法分析**：

- 时间复杂度：`O(nlogn)`。
- 空间复杂度：`O(n)`。
- **归并排序是稳定排序**。



## 5. 基数排序

**基本思想**：分配 + 收集。基数排序也叫做**桶排序或箱排序**。设置若干个箱子，将关键字为 *k*  的记录放入第 *k* 个箱子，然后在按序号将非空的连接。

**基数排序**：数字是有范围的，均由 *0-9* 这十个数字组成，则只需要设置是个箱子，相继按个、十、百...进行排序。

![基数排序](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201110204932234.png)

![基数排序](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201110210012678.png)

![基数排序](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/2020111021003840.png)

```c
/**
* 求数据的最大位数
* @Param int a[] 待排数组
* @Param int N   待排数组长度
*/
int maxbit(int a[], int N) {

	// 找到数组中的最大元素
	int max = a[0];
	for(int i = 1; i < N; i++) {
		if(a[i] > max) max = a[i];
	}

	int cnt = 0;
	int temp = max;
	while(temp > 0) {
		temp /= 10;
		cnt++;
	}
	return cnt;
}

/**
* 基数排序
*
* @Param int* a 待排数组
* @Param int  N 待排数组长度 
*/ 
void sort(int* a, int N) {
	int mbit = maxbit(a, N);                               // 数据的最大位数
	int* temp = (int*)malloc(sizeof(int) * N);             // 临时数组
	int* count = (int*)malloc(sizeof(int) * 10);           // 计数器(桶)

	int radix = 1;                                         // 用于"/10"或"/100"等 方便获得数据的各位的值
	
	// 根据数据的最大位数来确定要进行基数排序的次数 
	for(int i = 1; i <= mbit; i++) {
		// 计数器(桶)初始化
		for(int j = 0; j < 10; j++)
			count[j] = 0;

		// 统计每个桶中的记录数
		for(int j = 0; j < N; j++) {
			int k = (a[j] / radix) % 10;
			count[k]++;
		}

		// 将 temp 数组中的位置依次分配给每个桶(这里牛B)！ 
		for(int j = 1; j < 10; j++)
			count[j] = count[j-1] + count[j];

		// 将桶中所有记录依次收集到 temp 数组中(这里也牛B)! 
		for(int j = N - 1; j >= 0; j--) {
			int k = (a[j] / radix) % 10;
			temp[count[k] - 1] = a[j];
			count[k]--;                 // 这里的计数器-1至关重要 
		}

		// 将 temp 数组中的数据复制到 a 数组中
		for(int j = 0; j < N; j++)
			a[j] = temp[j];

		radix *= 10;
	}

}
```

## 6. 各种排序方法的比较

![各种排序方法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20201110210752403.png)

# 欧几里得算法

计算两个非负整数`p`和`q`的最大公约数算法：

- 若`q`是0，则最大公约数为`p`。
- 若`q`不是0，将`p`除以`q`得到余数`r`，`p`和`q`的最大公约数即为`q`和`r`的最大公约数。

```java
/**
 * 使用欧几里得算法计算最大公约数
 */
public class Gcd {
    public static void main(String[] args) {
        System.out.println(gcd(10, 0)); // 10
        System.out.println(gcd(100, 25)); // 25
    }

    public static int gcd(int p, int q) {
        if (q == 0) return p;
        int r = p % q;
        return gcd(q, r);
    }
}
```

# 1.排序

## 1.1.封装工具类

```java
/**
 * 学习排序算法需要使用的工具类
 */
public class SortedUtils {
    
    /**
     * 比较v和w的大小
     *
     * @return v比w小返回true, 反之返回false
     */
    public static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }

    // 交换数组中两个元素的位置
    public static void exchange(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    // 测试数组元素是否升序排序
    public static boolean isSorted(Comparable[] a) {
        for (int i = 0; i < a.length - 1; i++) {
            if (less(a[i + 1], a[i])) {
                return false;
            }
        }
        return true;
    }
    
    // 输出数组的内容
    public static void show(Comparable[] a) {
        int N = a.length;
        String ret = "[";
        for (int i = 0; i < N; i++) {
            if (i != (N - 1)) {
                ret += a[i] + ",";
            } else {
                ret += a[N - 1] + "]";
            }
        }
        System.out.println(ret);
    }    
}
```

## 1.2.初级排序算法

### 1.2.1.选择排序

选择排序算法：

- 找到数组中最小的那个元素`min`；
- 将`min`和数组中第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）；
- 在剩下的元素中找到最小的元素，将它与数据的第二个元素交换位置。
- 执行上述循环，直到将整个数组排序。

```java
import static com.ymy.sort.utils.SortedUtils.*;

/**
 * 选择排序：不断地选择剩余元素之中的最小者
 */
public class Selection {

    public static void main(String[] args) {
        Integer[] a = {-2, 100, 20, 9};
        sort(a);
        show(a); // [-2, 9, 20, 100]
    }

    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i = 0; i < N; i++) {
            int min = i;
            for (int j = i + 1; j < N; j++) {
                if (less(a[j], a[min])) {
                    min = j;
                }
            }
            exchange(a, i, min);
        }
    }
}
```

选择排序特点：

- **运行时间和输入无关。**一个已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间是一样长的。
- **数据移动最少。**每次交换都会改变两个数组元素的值，因此选择排序用了N次交换——交换次数和数组的大小是线性关系。

### 1.2.2.插入排序

插入排序算法：通常人们整理桥牌的方法是一张一张的来，将每一张牌插入到其他已经有序的牌中的适当位置。在计算机的实现中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。

> 基本的插入排序算法

```java
import static com.ymy.sort.utils.SortedUtils.*;

/**
 * 插入排序
 * [44, 69, 40, 98, 80, 25, 36, 96, 17, 11]
 *
 * [44, 69, 40, 98, 80, 25, 36, 96, 17, 11] i=1
 * [40, 44, 69, 98, 80, 25, 36, 96, 17, 11] i=2
 * [40, 44, 69, 98, 80, 25, 36, 96, 17, 11] i=3
 * [40, 44, 69, 80, 98, 25, 36, 96, 17, 11] i=4
 * [25, 40, 44, 69, 80, 98, 36, 96, 17, 11] i=5
 * [25, 36, 40, 44, 69, 80, 98, 96, 17, 11] i=6
 * [25, 36, 40, 44, 69, 80, 96, 98, 17, 11] i=7
 * [17, 25, 36, 40, 44, 69, 80, 96, 98, 11] i=8
 * [11, 17, 25, 36, 40, 44, 69, 80, 96, 98] i=9
 */
public class Insertion {

    public static void main(String[] args) {
        Integer[] a = new Integer[]{44, 69, 40, 98, 80, 25, 36, 96, 17, 11};
        sort(a);
    }

    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i = 1; i < N; i++) {
            for (int j = i; j > 0 && less(a[j], a[j - 1]); j--) {
                exchange(a, j, j - 1);
            }
            //show(a);
        }
    }
}
```

插入排序与选择排序的异同点：

- 与选择排序一样，当前索引左边的所有元素都是有序的，但是它们的最终位置还不能确定，为了给更小的元素腾出空间，它们可能会被移动。但是当索引达到数组的右端时，数组排序就完成了。
- 和选择排序不同的是，**插入排序所需的时间取决于输入中元素的初始顺序。**

> 插入排序的改进算法

要大幅度提高插入排序速度并不难，只需要在内循环中将较大的元素都向右移动而不总是交换两个元素，这样访问数组的次数就能减半。

```java
import static com.ymy.sort.utils.SortedUtils.*;

/**
 * 插入排序改进算法
 * [44, 69, 40, 98, 80, 25, 36, 96, 17, 11]
 *
 * [44, 69, 40, 98, 80, 25, 36, 96, 17, 11] i=1
 * [40, 44, 69, 98, 80, 25, 36, 96, 17, 11] i=2
 * [40, 44, 69, 98, 80, 25, 36, 96, 17, 11] i=3
 * [40, 44, 69, 80, 98, 25, 36, 96, 17, 11] i=4
 * [25, 40, 44, 69, 80, 98, 36, 96, 17, 11] i=5
 * [25, 36, 40, 44, 69, 80, 98, 96, 17, 11] i=6
 * [25, 36, 40, 44, 69, 80, 96, 98, 17, 11] i=7
 * [17, 25, 36, 40, 44, 69, 80, 96, 98, 11] i=8
 * [11, 17, 25, 36, 40, 44, 69, 80, 96, 98] i=9
 */
public class InsertionHalfExchange {

    public static void main(String[] args) {
        Integer[] a = new Integer[]{44, 69, 40, 98, 80, 25, 36, 96, 17, 11};
        sort(a);
    }

    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i = 1; i < N; i++) {
            Comparable temp = a[i]; // 用temp来保存当前索引值
            int j = i;
            while (j > 0 && less(temp, a[j - 1])) {
                // 当前索引值比前边的数都小时，就整体后移一位(当前索引左边的元素都是有序的)
                a[j] = a[j - 1]; 
                j--;
            }
            a[j] = temp; // 最后再temp的值插入
            //show(a);
        }
    }
}
```

### 1.2.3.希尔排序

希尔排序算法：

- 希尔排序是基于插入排序的快速的排序算法。
- 对于大规模乱序数组插入排序很慢，因为它只会交换相邻元素，元素只能一点一点地从数组的一端移动到另一端。
- **希尔排序的思想是使数组中任意间隔为h的元素都是有序的。**这样的数组被称为h有序数组。换句话说，一个h有序数组就是h个互相独立的有序数组编织在一起组成的一个数组。

![h有序数组](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20200808141957212.png)

> 希尔排序算法

```java
import static com.ymy.sort.utils.SortedUtils.*;

/**
 * 希尔排序
 * [S, H, E, L, L, S, O, R, T, E, X, A, M, p, L, E]
 * 
 * [L, E, E, A, M, H, L, E, S, S, O, L, T, p, X, R]
 * [A, E, E, E, H, L, L, L, M, O, R, S, S, T, X, p]
 */
public class Shell {

    public static void main(String[] args) {
        String[] a = new String[]{"S", "H", "E", "L", "L", "S", "O", "R", "T", "E", "X", "A", "M", "p", "L", "E"};
        sort(a);
    }
    
    public static void sort(Comparable[] a) {
        int N = a.length;
        int h = 1;
        while (h < N / 3) h = 3 * h + 1;
        while (h >= 1) {
            for (int i = h; i < N; i++) {
                for (int j = i; j >= h && less(a[j], a[j - h]); j -= h) {
                    exchange(a, j, j - h);
                }
            }
            h = h / 3;
        }
    }
}
```

### 1.2.4.比较三种排序算法

```java
import com.ymy.sort.Insertion;
import com.ymy.sort.Selection;
import com.ymy.sort.InsertionHalfExchange;
import com.ymy.sort.Shell;
import edu.princeton.cs.algs4.StdRandom;
import edu.princeton.cs.algs4.Stopwatch;


/**
 * 比较排序算法
 */
public class SortCompare {

    public static Double time(String alg, Comparable[] a) {
        Stopwatch timer = new Stopwatch();
        if (alg.equals("Selection")) Selection.sort(a);
        if (alg.equals("Insertion")) Insertion.sort(a);
        if (alg.equals("InsertionHalfExchange")) InsertionHalfExchange.sort(a);
        if (alg.equals("Shell")) Shell.sort(a);
        return timer.elapsedTime();
    }

    public static double timeRandomInput(String alg, int N, int T) {
        double total = 0.0;
        Double[] a = new Double[N];
        for (int t = 0; t < T; t++) {
            for (int i = 0; i < N; i++) {
                a[i] = StdRandom.uniform();
            }
            total += time(alg, a);
        }
        return total;
    }


    public static void main(String[] args) {
        // 下面使用不同的算法対长度为10000的随机数组进行排序,执行100次所需的时间
        System.out.println(timeRandomInput("Selection", 1_0000, 100)); // 12.11s
        System.out.println(timeRandomInput("Insertion", 1_0000, 100)); // 15.97s
        System.out.println(timeRandomInput("InsertionHalfExchange", 1_0000, 100)); // 7.39s
        System.out.println(timeRandomInput("Shell", 1_0000, 100)); // 0.28s
    }
}
```

**希尔排序算法比插入排序和选择排序都要快的多，并且数组越大，优势越大。**通过测试，长度100万的随机数组，使用希尔排序只需要1.5秒的时间，希尔排序能够解决一些初级排序算法无法解决的问题。

有经验的程序员有时会选择希尔排序，因为对于中等大小的数组它的运行时间是可以接受的。**希尔排序的代码量很小，并且不需要额外的运行空间**，后面接触到的更加高效的算法，对于很大的N，它们可能只会比希尔排序快两倍（可能还打不到）。

## 1.3.归并排序

归并排序：

- 要将一个数组排序，可以先（递归地）将 它分成两半分别排序，然后将结果归并起来。
- 归并排序最引人注目的性质是它能够保证将任意长度为N的数组排序所需的时间和`NlogN`成正比，它的主要 缺点是所需要的额外空间和`N`成正比。      

```java
package com.ymy.sort;

import com.ymy.sort.utils.SortCompare;

import static com.ymy.sort.utils.SortedUtils.*;

/**
 * 归并排序
 */
public class Merge {
    /**
     * 归并需要的额外的数组
     */
    private static Comparable[] aux;

    public static void sort(Comparable[] a) {
        aux = new Comparable[a.length];  // 数组aux初始化
        sort(a, 0, a.length - 1);
    }

    /**
     * 归并排序
     *
     * @param a  目标数组
     * @param lo 开始下标
     * @param hi 结束下标
     */
    private static void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) return; // 递归的出口
        int mid = (lo + hi) >>> 1; // 计算mid中间值
        sort(a, lo, mid); // 将左半边排序
        sort(a, mid + 1, hi); // 将右半边排序
        merge(a, lo, mid, hi); // 归并结果
    }

    /**
     * 原地归并方法
     * 将a[lo...mid]和a[mid+1...hi]归并
     * 前提：a[lo...mid]和a[mid+1...hi]都是有序的！
     * For Example：
     * 0  1  2  3  4  5  6  7    8  9  10 11 12 13 14 15
     * E  E  G  M  O  R  R  S |  A  E  E  L  M  P  T  X
     * 主要比较aux[i]和aux[j]的大小,只要满足less(aux[j],a[i])那么a[k]=aux[j++],
     * 其他情况下就是a[k]=aux[i++];不过当i>mid的时候,就是左边遍历完了,就是a[k]=aux[j++];
     * 右边遍历完了就是a[k]=aux[i++]
     *
     * @param a   目标数组
     * @param lo  开始下标
     * @param mid 中间下标
     * @param hi  结束下标
     */
    private static void merge(Comparable[] a, int lo, int mid, int hi) {
        int i = lo;
        int j = mid + 1;

        // 将a[lo..hi]复制到aux[lo..hi]
        for (int k = lo; k <= hi; k++) {
            aux[k] = a[k];
        }

        // 将aux数组归并到a数组中
        for (int k = lo; k <= hi; k++) {
            if (i > mid)
                a[k] = aux[j++];
            else if (j > hi)
                a[k] = aux[i++];
            else if (less(aux[j], aux[i]))
                a[k] = aux[j++];
            else
                a[k] = aux[i++];
        }
    }

    public static void main(String[] args) {

        /**
         * 1、测试基本的排序
         */
        Integer[] a = new Integer[]{44, 69, 40, 98, 80, 25, 36, 96, 17, 11};
        sort(a);
        show(a); // [11, 17, 25, 36, 40, 44, 69, 80, 96, 98]

        /**
         * 2、测试性能：
         * 长度为100W的随机数组排序1次需要0.833s
         * 长度为1000W的随机数组排序1次需要8.653s长度为1000W的随机数组排序1次需要8.653s
         */
        System.out.println(SortCompare.timeRandomInput("Merge", 1000_000, 1));
        System.out.println(SortCompare.timeRandomInput("Merge", 1000_0000, 1));
    }
}
```

归并排序是应用高效算法设计中**分治思想**的最典型的一个例子。这和之前的初级排序算法不可同日而语，它表明我们只需要比遍历整个数组多个对数因子的时间就能将一个庞大的数组排序。**可以用归并排序处理数百万甚至更大规模的数组**！



## 1.4.快速排序

快速排序：

- **快速排序是一种分治的排序算法**。它将一个数组分成两个子数组，将两部分独立的排序。
- 快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。
- 在归并排序中，递归调用发生在处理整个数组之前，一个数组被切分成两半；在快速排序中，递归调用发生在处理整个数组之后，切分的位置取决于数组的内容。

```java
package com.ymy.sort;

import com.ymy.sort.utils.SortCompare;

import static com.ymy.sort.utils.SortedUtils.*;

/**
 * 快速排序
 */
public class Quick {

    /**
     * 快速排序封装
     *
     * @param a 目标数组
     */
    public static void sort(Comparable[] a) {
        sort(a, 0, a.length - 1);
    }

    /**
     * 快速排序
     *
     * @param a  目标数组
     * @param lo 开始下标
     * @param hi 结束下标
     */
    private static void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) return; // 递归的出口
        int j = partition(a, lo, hi); // 获得数组的切分点
        sort(a, lo, j - 1); // 将左半部分a[lo..j-1]排序
        sort(a, j + 1, hi); // 将右半部分a[j+1..hi]排序
    }

    /**
     * 获取快速排序切分点(partition:隔断)
     * 将数组切分为a[lo..i-1],a[i],a[i+1..hi]
     * <p>
     * 0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
     * K  R  A  T  E  L  E  P  U  I  M  Q  C  X  O  S
     * v=K;
     * less(a[1],K); 指针从左向右移动
     * less(K,a[15]); 指针从右向左移动
     * 当左-->右的时候,说明左边指针指向的值是大于K的,所以要交换下标i,j的值。
     * 当右-->左的时候,说明右边指针指向的值是小于K的,所以要交换下标i,j的值。
     *
     * @param a  目标数组
     * @param lo 开始下标
     * @param hi 结束下标
     * @return 快速排序的切分点
     */
    private static int partition(Comparable[] a, int lo, int hi) {
        int i = lo, j = hi + 1; // 左右扫描指针
        Comparable v = a[lo]; // 切分数组的元素
        while (true) {
            while (less(a[++i], v)) if (i == hi) break; // 指针从左向右移动
            while (less(v, a[--j])) if (j == lo) break; // 指针从右向左移动
            if (i >= j) break;  // 退出循环的临界条件i大于j
            exchange(a, i, j);
        }
        exchange(a, lo, j); // 将v=a[j]放入正确的位置
        return j;
    }

    public static void main(String[] args) {
        /**
         * 1、测试基本的排序
         */
        Integer[] a = new Integer[]{44, 69, 40, 98, 80, 25, 36, 96, 17, 11};
        sort(a);
        show(a); // [11, 17, 25, 36, 40, 44, 69, 80, 96, 98]

        /**
         * 2、测试性能：
         * 长度为100W的随机数组排序1次需要0.485s
         * 长度为1000W的随机数组排序1次需要5.197s
         */
        System.out.println(SortCompare.timeRandomInput("Quick", 100_0000, 1)); // 0.485s
        System.out.println(SortCompare.timeRandomInput("Quick", 1000_0000, 1)); // 5.197s
    }
}
```

快速排序算法，可能是应用最广泛的排序算法了。快速排序算法流行的原因是实现简单，适用于各种不同的输入数据并且在一般应用中比其他排序算法都要快的多。

**快速排序引人注目的特点**：

- 它是原地排序（只需要一个很小的辅助栈）；
- 将长度为N的数组排序所需的时间和`NlgN`成正比。

**快速排序的缺点**：

- 快速排序非常脆弱，在实现时要非常小心才能避免低劣的性能。

> 快速排序算法改进

和大多数递归排序算法一样，改进快速排序性能的一个简单办法基于以下两点：

- 对于小数组，快速排序比插入排序慢；
- 因为递归，快速排序的`sort()`方法在小数组中也会调用自己。**因此，在排序小数组时应该切换到插入排序**。

```java
// 将sort()中的语句
if (hi <= lo) return;

// 替换为
if (hi <= lo + M) {
    Insertion.sort(a, lo, hi);
    return;
}

public static void sort(Comparable[] a, int lo, int hi) {
    for(int i = lo + 1; i < hi; ++i) {
        for(int j = i; j > lo && less(a[j], a[j - 1]); --j) {
            exch((Object[])a, j, j - 1);
        }
    }
    assert isSorted(a, lo, hi);
}
```

转换参数`M`的最佳值是和系统相关的，但是`5~15`之间的任意值在大多数情况下都能令人满意。

# 2.查找

## 2.1.二分查找

```java
package com.ymy.search;

/**
 * 二分查找：前提必须是有序序列
 */
public class BinarySearch {

    private Comparable[] Keys;

    public void setKeys(Comparable[] keys) {
        Keys = keys;
    }

    /**
     * 二分查找(迭代)
     *
     * @param Key 要查找的值
     * @return 找到的值的下标
     */
    public int rankIter(Comparable Key) {
        int lo = 0, hi = Keys.length - 1;
        while (lo <= hi) {
            int mid = (lo + hi) >>> 1;
            int cmp = Key.compareTo(Keys[mid]);
            if (cmp < 0)
                hi = mid - 1;
            else if (cmp > 0)
                lo = mid + 1;
            else
                return mid;
        }
        return -1;
    }

    /**
     * 二分查找(递归)
     *
     * @param Key 要查找的值
     * @return 找到的值的下标
     */
    public int rank(Comparable Key) {
        return rank(Key, 0, Keys.length - 1);
    }

    /**
     * 递归的二分查找
     *
     * @param key 要查找的值
     * @param lo  开启下标
     * @param hi  结束下标
     * @return 找到的值的下标
     */
    private int rank(Comparable key, int lo, int hi) {
        if (hi < lo) return -1; // 递归的出口,证明没有搜索到
        int mid = (lo + hi) >>> 1;
        int cmp = key.compareTo(Keys[mid]);
        if (cmp < 0)
            return rank(key, lo, mid - 1);
        else if (cmp > 0)
            return rank(key, mid + 1, hi);
        else
            return mid;
    }

    public static void main(String[] args) {
        BinarySearch bs = new BinarySearch();
        bs.setKeys(new Integer[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10});
        System.out.println(bs.rank(1)); // 0
        System.out.println(bs.rank(90)); // -1
        System.out.println(bs.rankIter(5)); // 4
        System.out.println(bs.rankIter(-1)); // -1
    }
}
```

## 2.2.二叉查找树

```java
package com.ymy.search;

/**
 * 二叉搜索树
 *
 * @param <Key>   键
 * @param <Value> 值
 */
public class BST<Key extends Comparable<Key>, Value> {
    /**
     * 定义节点Node
     */
    private class Node {
        private Key key;            // 键
        private Value val;          // 值
        private Node left, right;   // 指向子树的链接
        private int N;              // 以该节点为根的子树中的结点总数

        public Node(Key key, Value val, int N) {
            this.key = key;
            this.val = val;
            this.N = N;
        }
    }

    /**
     * BST的根结点
     */
    private Node root;

    /**
     * @return 获得BST的结点总数
     */
    public int size() {
        return size(root);
    }

    /**
     * @param x 当前结点Node
     * @return 获得以当前结点为根的子树中节点总数
     */
    private int size(Node x) {
        if (x == null)
            return 0;
        else
            return x.N;
    }

    /**
     * BST中插入键值,并初始化根结点root
     *
     * @param key 键
     * @param val 值
     */
    public void put(Key key, Value val) {
        root = put(root, key, val);
    }

    /**
     * 在当前结点下插入键值
     *
     * @param x   当前结点
     * @param key 键
     * @param val 值
     * @return 当前结点
     */
    private Node put(Node x, Key key, Value val) {
        // 如果根结点root没有创建就创建根结点
        if (x == null)
            return new Node(key, val, 1);
        int cmp = key.compareTo(x.key);
        if (cmp < 0)
            x.left = put(x.left, key, val);
        else if (cmp > 0)
            x.right = put(x.right, key, val);
        else
            x.val = val;
        x.N = size(x.left) + size(x.right) + 1;
        return x;
    }

    /**
     * BST的root为根结点查找key所对应的值
     *
     * @param key 键
     * @return 值 val
     */
    public Value get(Key key) {
        return get(root, key);
    }

    /**
     * 在以x为根结点的子树中查找Key所对应的值
     *
     * @param x   子树的根结点
     * @param key 键
     * @return 值 Val
     */
    private Value get(Node x, Key key) {
        // 递归的出口,如果找不到就返回null
        if (x == null) return null;
        int cmp = key.compareTo(x.key);
        if (cmp < 0)
            return get(x.left, key);
        if (cmp > 0)
            return get(x.right, key);
        else
            return x.val;
    }
}
```

使用二叉查找树的算法的运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。

在最好的情况下，一颗含有N个结点的树是完全平衡的，每条空链接和根结点的距离都为~`lgN`。

在最坏的情况下，搜索路径上可能有N个节点，二叉树会变成单链表的数据结构。

但是在一般情况下，树的情况和最好情况更接近。

对于这种二分的模型而言，二叉查找树和快速排序几乎就是"双胞胎"。树的根结点就是快速排序中的第一个切分元素（左侧的键都比它小，右侧的键都比它大），而对于所有的子树同样适用，这和快速排序中対子数组的递归排序完全对应。

## 3.3.红黑树

红黑树的定义是含有红黑链并满足下列条件的二叉查找树：

- 红链接均为左链接；
- 没有任何一个结点同时和两条红链接相连；
- 该树是**完美黑色平衡**的，即任意空链接到根结点的路径上的黑链接数量相同。

颜色表示：

- 每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们将链接的颜色保存在表示结点`Node`数据类型的布尔变量`color`中；
- 如果指向当前结点的链接是红色的，那么布尔变量`color`的值就为`true`，黑色则为`false`，**我们约定空链接为黑色**。

红黑树的插入操作遵守以下规则：

- 如果右子结点是红色而左子结点是黑色的，进行左旋转；
- 如果左子结点是红色的且它的左子结点也是红色的，进行右旋转；
- 如果左右子结点均为红色，进行颜色转换。

```java
package com.ymy.search;

/**
 * 红黑树
 *
 * @param <Key>   键
 * @param <Value> 值
 */
public class RedBlackBST<Key extends Comparable<Key>, Value> {

    private static final boolean RED = true;    // 红链接
    private static final boolean BLACK = false; // 黑链接

    /**
     * 定义结点Node
     */
    private class Node {
        Key key;           // 键
        Value val;         // 值
        Node left, right;  // 指向子树的链接
        int N;             // 以该节点为根的子树中的结点总数
        boolean color;     // 其父结点指向它的链接的颜色

        public Node(Key key, Value val, int N, boolean color) {
            this.key = key;
            this.val = val;
            this.N = N;
            this.color = color;
        }
    }

    /**
     * 定义红黑树根结点
     */
    private Node root;

    /**
     * @return 红黑树结点总数
     */
    public int size() {
        return size(root);
    }

    /**
     * 红黑树的root为根结点查找key所对应的值
     *
     * @param key 键
     * @return 值 val
     */
    public Value get(Key key) {
        return get(root, key);
    }

    /**
     * 在以h为根结点的子树中查找Key所对应的值
     *
     * @param h   子树的根结点
     * @param key 键
     * @return 值 val
     */
    private Value get(Node h, Key key) {
        if (h == null) return null;
        int cmp = key.compareTo(h.key);
        if (cmp < 0)
            return get(h.left, key);
        else if (cmp > 0)
            return get(h.right, key);
        else
            return h.val;
    }

    /**
     * 红黑树根结点下插入键值
     *
     * @param key 键
     * @param val 值
     */
    public void put(Key key, Value val) {
        root = put(root, key, val);
        root.color = BLACK;
    }


    /**
     * 红黑树中当前结点下插入键值
     *
     * @param h   当前结点
     * @param key 键
     * @param val 值
     * @return 当前结点
     */
    private Node put(Node h, Key key, Value val) {
        if (h == null)
            return new Node(key, val, 1, RED);
        int cmp = key.compareTo(h.key);
        if (cmp < 0)
            h.left = put(h.left, key, val);
        else if (cmp > 0)
            h.right = put(h.right, key, val);
        else
            h.val = val;
        if (isRed(h.right) && !isRed(h.left)) h = rotateLeft(h);
        if (isRed(h.left) && isRed(h.left.left)) h = rotateRight(h);
        if (isRed(h.left) && isRed(h.right)) flipColors(h);

        h.N = size(h.left) + size(h.right) + 1;

        return h;
    }

    /**
     * @param x 当前结点Node
     * @return 获得以当前结点为根的子树中节点总数
     */
    private int size(Node x) {
        if (x == null)
            return 0;
        else
            return x.N;
    }

    /**
     * 指向当前结点的链接是否是红链接
     *
     * @param x 当前结点Node
     * @return true表示是红链接;false表示是黑链接
     */
    private boolean isRed(Node x) {
        if (x == null)
            return false;
        return x.color == RED;
    }

    /**
     * 左旋
     *
     * @param h 当前结点
     * @return 左旋后的父结点
     */
    private Node rotateLeft(Node h) {
        Node x = h.right;
        h.right = x.left;
        x.left = h;
        x.color = h.color;
        h.color = RED;
        x.N = h.N;
        h.N = 1 + size(h.left) + size(h.right);
        return x;
    }

    /**
     * 右旋
     *
     * @param h 当前结点
     * @return 右旋后的父结点
     */
    private Node rotateRight(Node h) {
        Node x = h.left;
        h.left = x.right;
        x.right = h;
        x.color = h.color;
        h.color = RED;
        x.N = h.N;
        h.N = 1 + size(h.left) + size(h.right);
        return x;
    }

    /**
     * 颜色转换
     *
     * @param h 当前结点
     */
    private void flipColors(Node h) {
        h.color = RED;
        h.left.color = BLACK;
        h.right.color = BLACK;
    }
}
```

## 3.4.散列表

`java`对于`hashCode()`的约定：

- 每种数据类型都需要相应的散列函数，于是`java`令所有数据类型都继承了一个能够返回一个32位比特整数的`hashCode()`方法。每一种数据类型的`hashCode()`方法都必须和`equals()`方法一致；
- 如果`a.equals(b)`返回`true`，那么`a.hashCode()`的返回值必然和`b.hashCode()`的返回值相同；
- 如果两个对象的`hashCode()`方法的返回值不同，那么我们就知道这两个对象是不同的。
- 但是如果两个对象的`hahCode()`方法的返回值相同，这两个对象也有可能不同，我们还需要用`equals()`方法进行判断。

> 自定义类型中`hashCode()`的实现

```java
public class Transaction {
    private final String who;
    private final Date when;
    private final double amount;
    
    public int hashCode() {
        int hash = 1;
        int hash = 31 * hash + this.who.hashCode();
        hash = 31 * hash + this.when.hashCode();
        hash = 31 * hash + Double.valueOf(this.amount).hashCode();
        return hash;
    }
}
```

> 基于拉链法的散列表

```java
package com.ymy.search;

/**
 * 基于拉链法的散列表
 *
 * @param <Key>   键
 * @param <Value> 值
 */
public class SeparateChainingHashST<Key, Value> {

    /**
     * 键值对总数
     */
    private int N;

    /**
     * 散列表的大小
     */
    private int M;

    /**
     * 存放链表对象的数组
     */
    private SequentialSearchST<Key, Value>[] st;

    public SeparateChainingHashST() {
        this(997);
    }

    public SeparateChainingHashST(int M) {
        this.M = M;
        st = (SequentialSearchST<Key, Value>[]) new SequentialSearchST[M];
        for (int i = 0; i < M; i++) {
            st[i] = new SequentialSearchST();
        }
    }

    public Value get(Key key) {
        return (Value) st[hash(key)].get(key);
    }

    /**
     * 散列表中插入键值
     *
     * @param key 键
     * @param val 值
     */
    public void put(Key key, Value val) {
        st[hash(key)].put(key, val);
    }

    private int hash(Key key) {
        return (key.hashCode() & 0x7fffffff) % M;
    }

    public static void main(String[] args) {
        SeparateChainingHashST<Integer, Object> hashST = new SeparateChainingHashST<>();
        for (int i = 1; i <= 10; i++) {
            hashST.put(i, 100 + i);
        }
        System.out.println(hashST.get(5));
    }
}
```

```java
package com.ymy.search;

/**
 * 单链表(顺序搜索)
 *
 * @param <Key>   键
 * @param <Value> 值
 */
public class SequentialSearchST<Key, Value> {

    /**
     * 链表结点定义
     */
    private class Node {
        Key key;
        Value val;
        Node next;

        public Node(Key key, Value val, Node next) {
            this.key = key;
            this.val = val;
            this.next = next;
        }
    }

    /**
     * 链表首结点
     */
    private Node first;

    /**
     * 单链表中插入键值
     * 查找给定的键,找到则更新其值,否则在表中新建结点
     *
     * @param key 键
     * @param val 值
     */
    public void put(Key key, Value val) {
        for (Node x = first; x != null; x = x.next) {
            // 命中,更新结点的值
            if (key.equals(x.key)) {
                x.val = val;
                return;
            }
        }
        // 未命中,新建结点(妙) 头插法
        first = new Node(key, val, first);
    }

    /**
     * 根据键在链表中查找值
     *
     * @param key 键
     * @return 值
     */
    public Value get(Key key) {
        for (Node x = first; x != null; x = x.next) {
            if (key.equals(x.key)) {
                return x.val;  // 命中
            }
        }
        return null;          // 未命中
    }
}
```

## 3.5.HashMap

> 1、HashMap内部数据结构

`JDK1.8`版本，`HashMap`内部使用数组 + 链表 + 红黑树。

![HashMap](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20200812143831704.png)

> 2、HashMap的数据插入原理

![HashMap插入流程](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20200812145624476.png)

流程：

- 判断数组是否为空，为空进行初始化；数组不为空，计算`Key`的`hash`值，通过`(length - 1) & hash`计算数组的下标。
- 查看`table[index]`是否存在数据，没有数据就构造一个`Node`结点存放在`table[index]`中；存在数据，说明发生了`Hash`冲突，继续判断`Key`是否相等；
- `Key`相等就替换`Value`的值；如果不相等，就将新的结点插入到链表或者红黑树中。
- 插入完成后判断当前结点数是否大于阈值，如果大于阈值`HashMap`开始扩容为原来数组的2倍。

> 3、HashMap初始化，如何设定初始容量的大小？

```java
/**
* Returns a power of two size for the given target capacity.
* 如果假设cap等于10
*/
static final int tableSizeFor(int cap) {
    int n = cap - 1;  // 9
    n |= n >>> 1;     // n = 9 | 4   ==> n = 13
    n |= n >>> 2;     // n = 13 | 3  ==> n = 15 
    n |= n >>> 4;     // n = 15 | 0  ==> n = 15
    n |= n >>> 8;     // n = 15 | 0  ==> n = 15
    n |= n >>> 16;    // n = 15 | 0  ==> n = 15
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; // 16
}
```

如果`new HashMap()`不指定容量，默认数组大小就是16，负载因子是0.75,；如果`new HashMap(capacity)`指定了初始容量，那么初始容量为大于`capacity`的2的整数次方，例如：传10，`HashMap`的初始容量就是16。

> 4、HashMap的哈希函数是如何设计的？

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

`hash()`函数式先拿到`key`的`hashCode`，是一个32位的`int`值，然后让`hashCode`的高16位和低16位做异或运算。

这样设计的原因：

- 尽可能降低`hash`碰撞，越分散越好；
- 算法一定要尽可能高效，采用位运算，效率会高。

> 5、为什么采用hashcode的高16位和低16位异或能降低hash碰撞？hash函数能不能直接用key的hashcode？

因为`Key.hashCode()`函数调用的是`Key`键值类型自带的哈希函数，返回`int`型散列值。`int`值范围为`-2147483648~2147483647`，前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。你想，如果`HashMap`数组的初始大小才16，用之前需要对数组的长度取模运算，得到的余数才能用来访问数组下标。

![计算索引下标](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20200812153340683.png)

> 6、JDK1.8对hash函数做了优化，1.8还有别的优化吗？

`jdk1.8`还有三点主要的优化：

- 1.数组 + 链表 ==>  数组 + 链表或红黑树；
- 2.链表的插入方式从头插法改成了尾插法，简单说就是插入时，如果数组位置上已经有元素，1.7将新元素放到数组中，原始节点作为新节点的后继节点，1.8遍历链表，将元素放置到链表的最后；
- 3.扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小；
- 4.在插入时，1.7先判断是否需要扩容，再插入，1.8先进行插入，插入完成再判断是否需要扩容；

> 7、分别讲讲这几点优化？

- 1.防止发生hash冲突，链表长度过长，将时间复杂度由`O(n)`降为`O(logn)`;
- 2.因为1.7头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；A线程在插入节点B，B线程也在插入，遇到容量不够开始扩容，重新hash，放置元素，采用头插法，后遍历到的B节点放入了头部，这样形成了环，如下图所示：

​     ![头插法](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20200812161636256.png)

- 3.扩容的时候为什么1.8 不用重新hash就可以直接定位原节点在新数据的位置呢?

  这是由于扩容是扩大为原数组大小的2倍，用于计算数组位置的掩码仅仅只是高位多了一个1，怎么理解呢？

  扩容前长度为16，用于计算`(n-1) & hash` 的二进制`n - 1`为`0000 1111`，扩容为32后的二进制就高位多了1，为`0001 1111`。因为是& 运算，1和任何数 & 都是它本身，那就分二种情况，如下图：原数据`hashcode`高位第4位为0和高位为1的情况；第四位高位为0，重新`hash`数值不变，第四位为1，重新`hash`数值比原来大16（旧数组的容量）。

  ![为什么不用rehash？](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20200812162404729.png)

> 8、那你平常怎么解决HashMap线程不安全的问题？

` Java中`有`HashTable`、`Collections.synchronizedMap`、以及`ConcurrentHashMap`可以实现线程安全的`Map`。

- `HashTable`是直接在操作方法上加`synchronized`关键字，锁住整个数组，粒度比较大;

```java
// HashTable中的put()方法
public synchronized V put(K key, V value) {
    // Make sure the value is not null
    if (value == null) {
        throw new NullPointerException();
    }

    // Makes sure the key is not already in the hashtable.
    Entry<?,?> tab[] = table;
    int hash = key.hashCode();
    int index = (hash & 0x7FFFFFFF) % tab.length;
    @SuppressWarnings("unchecked")
    Entry<K,V> entry = (Entry<K,V>)tab[index];
    for(; entry != null ; entry = entry.next) {
        if ((entry.hash == hash) && entry.key.equals(key)) {
            V old = entry.value;
            entry.value = value;
            return old;
        }
    }

    addEntry(hash, key, value, index);
    return null;
}
```

- `Collections.synchronizedMap`是使用`Collections`集合工具的内部类，通过传入Map封装出一个`SynchronizedMap`对象，内部定义了一个对象锁，方法内通过对象锁实现；

```java
private static class SynchronizedMap<K,V>implements Map<K,V>, Serializable {
    final Object      mutex;
    public V put(K key, V value) {
        synchronized (mutex) {return m.put(key, value);}
    }
}
```

- `ConcurrentHashMap`使用CAS算法，让并发度大大提高。`ConcurrentHashMap`成员变量使用`volatile `修饰，免除了指令重排序，同时保证内存可见性，另外使用CAS操作和`synchronized`结合实现赋值操作，多线程操作只会锁住当前操作索引的节点。

> 9、链表转红黑树是链表长度达到阈值，这个阈值是多少？

阈值是8，红黑树转链表阈值为6。

> 10、为什么是8，不是16，32甚至是7 ？又为什么红黑树转链表的阈值是6，不是8了呢？

因为经过计算，在`hash`函数设计合理的情况下，发生`hash`碰撞8次的几率为百万分之6，概率说话。。因为8够用了，至于为什么转回来是6，因为如果`hash`碰撞次数在8附近徘徊，会一直发生链表和红黑树的互相转化，为了预防这种情况的发生。

> 11、HashMap内部节点是有序的吗？那有没有有序的Map？

`HashMap` 是无序的，根据`hash`值随机插入。`LinkedHashMap `和 `TreeMap`是有序的。



`LinkedHashMap`内部维护了一个单链表，有头尾节点，同时`LinkedHashMap`节点Entry内部除了继承`HashMap`的`Node`结点，其中有`before` 和 `after`用于标识前置节点和后置节点。可以实现按插入的顺序或访问顺序排序。

```java
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>{
    
    transient LinkedHashMap.Entry<K,V> head;
    
    transient LinkedHashMap.Entry<K,V> tail;
    
    static class Entry<K,V> extends HashMap.Node<K,V> {
        Entry<K,V> before, after;
        Entry(int hash, K key, V value, Node<K,V> next) {
            super(hash, key, value, next);
        }
    }
    
    // link at the end of list
    private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {
        LinkedHashMap.Entry<K,V> last = tail;
        tail = p;
        if (last == null)
            head = p;
        else {
            p.before = last;
            last.after = p;
        }
    }
}
```

![LinkedHashMap](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20200329020913.png)







`TreeMap`是按照`Key`的自然顺序或者`Comparator`的顺序进行排序，内部是通过红黑树来实现。所以要么`Key`所属的类实现`Comparable`接口，或者自定义一个实现了`Comparator`接口的比较器，传给`TreeMap`用于`key`的比较。

















